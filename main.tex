\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, positioning, calc, patterns}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{framed}
\usepackage{stmaryrd}
\usepackage{graphicx}

\geometry{a4paper, margin=2.5cm}

\definecolor{myblue}{RGB}{0, 102, 204}
\definecolor{myred}{RGB}{204, 0, 0}
\definecolor{mygreen}{RGB}{0, 153, 76}

\usepackage{titlesec}
\titleformat{\section}
{\color{myblue}\normalfont\Large\bfseries}
{\color{myblue}\thesection}{1em}{}

\titleformat{\subsection}
{\color{myblue}\normalfont\large\bfseries}
{\color{myblue}\thesubsection}{1em}{}

\theoremstyle{definition}
\newtheorem{definizione}{Definizione}[section]
\newtheorem{teorema}{Teorema}[section]

\title{\textbf{\textcolor{myblue}{Definizioni Fondamentali}}\\ \large Analisi Statica e Verifica del Software}
\author{}
\date{}

\begin{document}

\maketitle

\section{Set (Insieme)}

\begin{definizione}[\textbf{Insieme}]
Un insieme (\textit{set}) è una collezione di oggetti ben definiti e distinti. La collezione stessa è considerata un oggetto a sé stante.
\end{definizione}

Dato un insieme $S$, valgono le seguenti notazioni fondamentali:
\begin{itemize}
    \item \textbf{Appartenenza:} $s \in S$ indica che l'elemento $s$ appartiene all'insieme $S$.
    \item \textbf{Sottoinsieme:} $S_1 \subseteq S_2 \iff \forall s \in S_1 \Rightarrow s \in S_2$.
    \item \textbf{Unione:} $S_1 \cup S_2 = \{s \mid s \in S_1 \vee s \in S_2\}$.
    \item \textbf{Intersezione:} $S_1 \cap S_2 = \{s \mid s \in S_1 \wedge s \in S_2\}$.
\end{itemize}

\section{Partial Order (Ordine Parziale)}

\begin{definizione}[\textbf{Ordine Parziale}]
Un ordine parziale è una relazione binaria $\sqsubseteq$ su un insieme $X$ che soddisfa le seguenti tre proprietà per ogni $x, y, z \in X$:
\begin{enumerate}
    \item \textbf{Riflessività:} $\forall x \in X \Rightarrow x \sqsubseteq x$.
    \item \textbf{Anti-simmetria:} $(x \sqsubseteq y \wedge y \sqsubseteq x) \Rightarrow x = y$.
    \item \textbf{Transitività:} $(x \sqsubseteq y \wedge y \sqsubseteq z) \Rightarrow x \sqsubseteq z$.
\end{enumerate}
\end{definizione}

\section{Poset (Insieme Parzialmente Ordinato)}

\begin{definizione}[\textbf{Poset}]
Un \textit{Poset} (Partially Ordered Set) è la coppia formata da un insieme $X$ e da una relazione di ordine parziale definita su di esso. Si denota formalmente come:
\[ \langle X, \sqsubseteq \rangle \]
\end{definizione}

\noindent \textbf{Esempio:} L'insieme dei numeri interi con la relazione "minore o uguale" è un poset: $\langle \mathbb{Z}, \le \rangle$.

\section{Powerset (Insieme delle Parti)}

\begin{definizione}[\textbf{Powerset}]
Dato un insieme $S$, l'insieme delle parti (\textit{powerset}) di $S$, indicato con $\wp(S)$ (o $\mathcal{P}(S)$), è l'insieme di tutti i sottoinsiemi di $S$:
\[ \wp(S) = \{ U \mid U \subseteq S \} \]
\end{definizione}

\noindent \textbf{Cardinalità:} Dato un insieme $S$ con $|S| = n$ elementi, il suo powerset ha $|\wp(S)| = 2^n$ elementi.

\noindent \textbf{Struttura di Poset:} Un powerset forma naturalmente un poset rispetto alla relazione di inclusione insiemistica: $\langle \wp(S), \subseteq \rangle$.

\newpage

\section{Bounds e Operazioni nel Powerset}

In un poset generico $\langle X, \sqsubseteq \rangle$, definiamo i concetti di limiti (bounds) per un sottoinsieme $Y \subseteq X$.

\subsection{Definizioni Astratte}

\begin{definizione}[\textbf{Upper Bound e LUB}]
\leavevmode
\begin{itemize}
    \item \textbf{Upper Bound (Maggiorante):} Un elemento $u \in X$ è un upper bound di $Y$ se è maggiore o uguale a tutti gli elementi di $Y$ ($\forall y \in Y, y \sqsubseteq u$).
    \item \textbf{Least Upper Bound (LUB o Join $\sqcup$):} È il più piccolo tra tutti gli upper bound. Se esiste, è unico.
\end{itemize}
\end{definizione}

\begin{definizione}[\textbf{Lower Bound e GLB}]
\leavevmode
\begin{itemize}
    \item \textbf{Lower Bound (Minorante):} Un elemento $l \in X$ è un lower bound di $Y$ se è minore o uguale a tutti gli elementi di $Y$ ($\forall y \in Y, l \sqsubseteq y$).
    \item \textbf{Greatest Lower Bound (GLB o Meet $\sqcap$):} È il più grande tra tutti i lower bound. Se esiste, è unico.
\end{itemize}
\end{definizione}

\subsection{Applicazione nel Powerset}

Nel caso specifico del Powerset $\langle \wp(S), \subseteq \rangle$, le operazioni astratte corrispondono alle operazioni insiemistiche classiche:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Concetto Astratto} & \textbf{Simbolo} & \textbf{Nel Powerset ($\subseteq$)} \\
\hline
Ordine Parziale & $\sqsubseteq$ & Inclusione ($\subseteq$) \\
Least Upper Bound (Join) & $\sqcup$ & \textbf{Unione ($\cup$)} \\
Greatest Lower Bound (Meet) & $\sqcap$ & \textbf{Intersezione ($\cap$)} \\
Elemento Top & $\top$ & Insieme Universo ($S$) \\
Elemento Bottom & $\bot$ & Insieme Vuoto ($\emptyset$) \\
\hline
\end{tabular}
\end{center}

\vspace{0.5cm}

\subsection{Rappresentazione Grafica (Diagramma di Hasse)}
Esempio del poset $\wp(\{a, b\})$ ordinato per inclusione.

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    \node (top) at (0,3) {$\{a, b\}$ ($\top$)};
    \node (a) at (-2,1.5) {$\{a\}$};
    \node (b) at (2,1.5) {$\{b\}$};
    \node (bot) at (0,0) {$\emptyset$ ($\bot$)};

    \draw (bot) -- (a);
    \draw (bot) -- (b);
    \draw (a) -- (top);
    \draw (b) -- (top);
    
    \node[right of=top, xshift=1cm, text width=4cm, font=\small, align=left, color=myred] {$\leftarrow$ \textbf{Upper Bound} di $\{a\}$ e $\{b\}$ (Unione)};
    \node[right of=bot, xshift=1cm, text width=4cm, font=\small, align=left, color=mygreen] {$\leftarrow$ \textbf{Lower Bound} di $\{a\}$ e $\{b\}$ (Intersezione)};
\end{tikzpicture}
\end{center}

\newpage

\section{Reticoli (Lattices)}

Un reticolo è un tipo speciale di poset "molto ordinato", in cui non ci si perde mai né salendo né scendendo.

\subsection{Lattice (Reticolo)}

\begin{definizione}[\textbf{Lattice}]
Un poset $\langle X, \sqsubseteq \rangle$ è un \textbf{Lattice} se, per \textbf{ogni coppia} di elementi $x, y \in X$, esistono sempre:
\begin{enumerate}
    \item Il loro \textbf{Join} $x \sqcup y$ (Least Upper Bound).
    \item Il loro \textbf{Meet} $x \sqcap y$ (Greatest Lower Bound).
\end{enumerate}
\end{definizione}

\noindent \textbf{Differenza visiva:}
\begin{itemize}
    \item \textbf{Join Semi-Lattice:} Converge sempre andando verso l'alto (come una V).
    \item \textbf{Meet Semi-Lattice:} Converge sempre andando verso il basso (come una $\wedge$).
    \item \textbf{Lattice:} È chiuso sia sopra che sotto (come un diamante).
\end{itemize}

\begin{center}
\begin{tikzpicture}

    \begin{scope} 
        \node at (0,0) (j1) {$\bullet$};
        \node at (1,0) (j2) {$\bullet$};
        \node at (0.5,1) (jtop) {$\bullet$};
        \draw (j1) -- (jtop);
        \draw (j2) -- (jtop);
        \node at (0.5, -0.5) {\textit{Join Semi-Lattice}};
    \end{scope}

    \begin{scope}[xshift=4cm] 
        \node at (0,1) (m1) {$\bullet$};
        \node at (1,1) (m2) {$\bullet$};
        \node at (0.5,0) (mbot) {$\bullet$};
        \draw (mbot) -- (m1);
        \draw (mbot) -- (m2);
        \node at (0.5, -0.5) {\textit{Meet Semi-Lattice}};
    \end{scope}

    \begin{scope}[xshift=8cm]
        \node at (0.5,0.5) (lbot) {$\bullet$};
        \node at (0,1.5) (l1) {$\bullet$};
        \node at (1,1.5) (l2) {$\bullet$};
        \node at (0.5,2.5) (ltop) {$\bullet$};
        \draw (lbot) -- (l1) -- (ltop) -- (l2) -- (lbot);
        \node at (0.5, -0.5) {\textit{Lattice}};
    \end{scope}

\end{tikzpicture}
\end{center}
\subsection{Set Lattice (Reticolo di Insiemi)}

È l'"istanza concreta" più comune di un reticolo.

\begin{definizione}[\textbf{Set Lattice}]
Dato un insieme $S$, il \textbf{Set Lattice} è la struttura formata dal suo powerset $\wp(S)$ equipaggiato con le operazioni insiemistiche classiche:
\[ \langle \wp(S), \subseteq, \cup, \cap \rangle \]
\end{definizione}

\noindent \textbf{Caratteristiche:}
\begin{itemize}
    \item \textbf{Dominio:} Insieme delle parti.
    \item \textbf{Join ($\sqcup$):} Unione ($\cup$).
    \item \textbf{Meet ($\sqcap$):} Intersezione ($\cap$).
\end{itemize}

\begin{center}
\begin{tikzpicture}[scale=0.8]
    \node (bot) at (0,0) {$\emptyset$};
    
    \node (n1) at (-3,1.5) {$\{-1\}$};
    \node (n0) at (0,1.5) {$\{0\}$};
    \node (p1) at (3,1.5) {$\{1\}$};
    
    \node (n10) at (-3,3) {$\{-1, 0\}$};
    \node (n1p1) at (0,3) {$\{-1, 1\}$};
    \node (n0p1) at (3,3) {$\{0, 1\}$};
    
    \node (top) at (0,4.5) {$\{-1, 0, 1\}$};

    \draw (bot) -- (n1); \draw (bot) -- (n0); \draw (bot) -- (p1);
    \draw (n1) -- (n10); \draw (n1) -- (n1p1);
    \draw (n0) -- (n10); \draw (n0) -- (n0p1);
    \draw (p1) -- (n1p1); \draw (p1) -- (n0p1);
    \draw (n10) -- (top); \draw (n1p1) -- (top); \draw (n0p1) -- (top);
    
    \node at (0, -1) {\textbf{Esempio:} Set Lattice su $\wp(\{-1,0,1\})$};
\end{tikzpicture}
\end{center}

\subsection{Complete Lattice (Reticolo Completo)}

\begin{definizione}[\textbf{Complete Lattice}]
Un reticolo è \textbf{completo} se Join ($\sqcup$) e Meet ($\sqcap$) esistono per \textbf{qualsiasi sottoinsieme} del dominio, anche infinito.
\end{definizione}

\noindent \textbf{Conseguenze importanti:}
\begin{itemize}
    \item Un reticolo completo ha sempre un elemento \textbf{Top} ($\top = \sqcup X$) e un elemento \textbf{Bottom} ($\bot = \sqcap X$).
    \item I reticoli finiti (come i Set Lattice su insiemi finiti) sono sempre completi.
    \item I numeri interi $\langle \mathbb{Z}, \le \rangle$ sono un Lattice ma \textbf{non} completo (mancano $\top$ e $\bot$). Per renderlo completo bisogna aggiungere $+\infty$ e $-\infty$.
\end{itemize}

\newpage

\section{Relazioni e Funzioni (Maps)}

Questi concetti matematici sono fondamentali per descrivere come cambiano gli stati di un programma durante l'esecuzione.

\subsection{Relazioni}

\begin{definizione}[\textbf{Relazione}]
Dati due insiemi $X$ e $Y$, una \textbf{relazione} $R$ è un sottoinsieme del prodotto cartesiano $X \times Y$:
\[ R \subseteq X \times Y \]
\end{definizione}

\noindent \textbf{Esempio:} L'ordine parziale $\sqsubseteq$ è una relazione definita su un insieme con se stesso ($R \subseteq X \times X$).

\subsection{Funzioni (Maps)}

\begin{definizione}[\textbf{Funzione}]
Una \textbf{funzione} (o mappa) $f: X \rightarrow Y$ è una relazione speciale che soddisfa la proprietà di \textbf{unicità dell'immagine}: per ogni input $x \in X$, esiste al massimo un output $y \in Y$.
\end{definizione}

\noindent Le funzioni sono usate per modellare lo stato della memoria (es. mappa \textit{variabile} $\rightarrow$ \textit{valore}).

\subsubsection{Proprietà delle Funzioni sui Poset}

Quando le funzioni operano su insiemi ordinati (Poset), ci interessano tre proprietà chiave per l'analisi statica.

\begin{definizione}[\textbf{Monotonia}]
Una funzione $f: X \rightarrow Y$ è \textbf{monotona} se preserva l'ordine:
\[ x_1 \sqsubseteq x_2 \implies f(x_1) \sqsubseteq f(x_2) \]
\textit{Intuitivamente:} Se l'input "cresce" (diventa più grande o più preciso), l'output non può "decrescere".
\end{definizione}

\begin{definizione}[\textbf{Embedding Ordinato}]
È una condizione più forte della monotonia. La funzione preserva l'ordine in entrambe le direzioni:
\[ x_1 \sqsubseteq x_2 \iff f(x_1) \sqsubseteq f(x_2) \]
La struttura dell'ordine viene conservata perfettamente nel passaggio da $X$ a $Y$.
\end{definizione}

\begin{definizione}[\textbf{Isomorfismo}]
È un embedding ordinato che è anche \textbf{suriettivo} (copre tutto il codominio $Y$). Significa che i due poset $X$ e $Y$ sono strutturalmente identici.
\end{definizione}

\vspace{0.5cm}

\begin{center}
\begin{tikzpicture}

    \begin{scope}
        \node at (2, 4.5) {\textbf{Funzione Monotona}};
        
        \node at (0,3) (x1) {1};
        \node at (0,2) (x0) {0};
        \node at (0,1) (xm1) {-1};
        \draw (xm1) -- (x0) -- (x1);
        \node at (0, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \node at (4,3) (y1) {1};
        \node at (4,2) (y0) {0};
        \node at (4,1) (ym1) {-1};
        \draw (ym1) -- (y0) -- (y1);
        \node at (4, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \draw[->, color=myred, thick] (x1) -- (y1);
        \draw[->, color=myred, thick] (x0) -- (y1);
        \draw[->, color=myred, thick] (xm1) -- (y0);

        \node at (2, -1.5) {\parbox{6cm}{\centering Se $x$ sale, la freccia non scende mai ($f(x_1) \sqsubseteq f(x_2)$).}};
    \end{scope}

    \begin{scope}[xshift=7.5cm]
        \node at (2.5, 4.5) {\textbf{Embedding Ordinato}};
        
        \node at (0,3) (x1) {1};
        \node at (0,2) (x0) {0};
        \node at (0,1) (xm1) {-1};
        \draw (xm1) -- (x0) -- (x1);
        \node at (0, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \node at (5,3) (y3) {3};
        \node at (5,2) (y2) {2};
        \node at (5,1) (y1) {1};
        \draw (y1) -- (y2) -- (y3);
        \node at (5, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \draw[->, color=blue, thick] (x1) -- (y3); 
        \draw[->, color=blue, thick] (x0) -- (y2);
        \draw[->, color=blue, thick] (xm1) -- (y1);

        \node at (2.5, -1.5) {\parbox{6cm}{\centering Struttura copiata identica ($f(x)=x+2$).\\ Iniettiva e bidirezionale.}};
    \end{scope}

\end{tikzpicture}
\end{center}
\section{Teoria del Punto Fisso e Terminazione}

Questa sezione copre i concetti matematici necessari per garantire che l'analisi statica termini e produca risultati corretti, specialmente in presenza di cicli.

\subsection{Chains (Catene)}

\begin{definizione}[\textbf{Catena}]
Dato un poset $\langle X, \sqsubseteq \rangle$, un sottoinsieme $C \subseteq X$ è una \textbf{catena} se è totalmente ordinato, ovvero tutti gli elementi sono confrontabili tra loro:
\[ \forall x, y \in C \implies (x \sqsubseteq y \lor y \sqsubseteq x) \]
\end{definizione}

\noindent \textbf{Catena Ascendente:} Una sequenza indicizzata $(l_n)_{n \in \mathbb{N}}$ tale che $i \le j \implies l_i \sqsubseteq l_j$.
\[ l_0 \sqsubseteq l_1 \sqsubseteq l_2 \sqsubseteq \dots \]
Nell'analisi statica, le catene ascendenti rappresentano l'accumulo progressivo di informazioni durante le iterazioni.

\subsection{ACC (Ascending Chain Condition)}

Questa proprietà è fondamentale per garantire la \textbf{terminazione} degli algoritmi di analisi.

\begin{definizione}[\textbf{ACC}]
Un poset soddisfa la \textbf{Ascending Chain Condition} se ogni catena ascendente infinita alla fine si \textbf{stabilizza}. Esiste un indice $k$ oltre il quale il valore non cambia più:
\[ \exists k \ge 0 \text{ tale che } \forall j \ge k, l_k = l_j \]
\end{definizione}

\noindent \textit{Intuizione:} Non è possibile "crescere" all'infinito. Se il dominio ha la ACC (es. è finito), l'analizzatore non andrà mai in loop infinito.

\subsection{Mappe Continue}

\begin{definizione}[\textbf{Funzione Continua}]
Siano $X$ e $Y$ due CPO (Complete Partial Orders). Una funzione $f: X \to Y$ è \textbf{continua} se preserva i limiti delle catene (i LUB):
\[ f\left(\bigsqcup C\right) = \bigsqcup_{c \in C} f(c) \]
\end{definizione}

\noindent \textbf{Nota:} La continuità è una condizione più forte della monotonia. È necessaria per applicare il Teorema di Kleene.

\subsection{Fixpoint (Punto Fisso)}

I punti fissi forniscono la semantica dei costrutti ciclici (loop).

\begin{definizione}[\textbf{Punto Fisso}]
Dato un insieme $X$ e una funzione $f: X \to X$, un elemento $x \in X$ è un punto fisso se:
\[ f(x) = x \]
\end{definizione}

\noindent Nell'analisi statica cerchiamo il \textbf{Least Fixpoint (lfp)}, ovvero il punto fisso più piccolo, che rappresenta l'insieme minimo dei comportamenti possibili del programma.

\subsubsection{Teoremi fondamentali}

\begin{itemize}
    \item \textbf{\textcolor{myblue}{Teorema di Knaster-Tarski:}} Se $\langle X, \sqsubseteq \rangle$ è un reticolo completo e $f$ è \textbf{monotona}, allora l'insieme dei punti fissi è un reticolo completo e il lfp esiste. \\
    \textit{Limite:} Non dice come calcolarlo (non costruttivo).
    
    \item \textbf{\textcolor{myblue}{Teorema di Kleene:}} Se $\langle X, \sqsubseteq \rangle$ è un CPO e $f$ è \textbf{continua}, allora il lfp è il limite dell'iterazione partendo dal basso ($\bot$):
    \[ lfp(f) = \bigsqcup_{n \in \mathbb{N}} f^n(\bot) \]
    \textit{Vantaggio:} Fornisce un algoritmo costruttivo (iterativo) usato dagli analizzatori.
\end{itemize}

\newpage

\section{Il Linguaggio IMP}

IMP è un linguaggio imperativo minimale ("toy language") utilizzato per modellare formalmente la semantica senza la complessità dei linguaggi reali. È Turing-completo.

\subsection{Sintassi}

La sintassi è divisa in tre categorie sintattiche:

\begin{enumerate}
    \item \textbf{Espressioni Aritmetiche ($e$):} Calcolano valori interi.
    \[ e ::= x \mid n \mid e_1 \ op_a \ e_2 \]
    \textit{Dove:} $x$ è una variabile, $n \in \mathbb{Z}$, $op_a \in \{+, -, *, \div\}$.

    \item \textbf{Espressioni Booleane ($b$):} Calcolano valori di verità (condizioni).
    \[ b ::= \text{true} \mid \text{false} \mid \neg b \mid b_1 \ op_b \ b_2 \mid e_1 \ op_c \ e_2 \]
    \textit{Dove:} $op_b \in \{\land, \lor\}$, $op_c \in \{==, <, >, \le\}$.

    \item \textbf{Statement (Comandi, $s$):} Modificano lo stato della memoria.
    \[ s ::= x := e \mid \text{skip} \mid s_1 ; s_2 \mid \text{if } b \text{ then } s_1 \text{ else } s_2 \mid \text{while } b \text{ do } s \]
\end{enumerate}

\subsection{Esempio di programma IMP}
Un programma che calcola la somma dei numeri da 0 a $x$:

\begin{verbatim}
y := 0;
while x > 0 do
    y := y + x;
    x := x - 1
\end{verbatim}

\section{Semantica delle Tracce}

\subsection{Definizione di Traccia}

\begin{definizione}[\textbf{Traccia}]
Una traccia $\tau \in X^\infty$ è una sequenza di stati che rappresenta una singola evoluzione del programma:
\begin{itemize}
    \item \textbf{Finite:} L'esecuzione termina in uno stato finale (es. il programma finisce).
    \item \textbf{Infinite:} L'esecuzione non termina (es. un ciclo \texttt{while(true)}).
    \item \textbf{Parziali:} Rappresentano un prefisso dell'esecuzione fino a un certo punto intermedio (es. se interrompiamo l'analisi).
\end{itemize}
\end{definizione}

\subsection{Semantica Concreta come Reticolo}
L'insieme di \textbf{tutte} le possibili esecuzioni (semantica concreta) viene modellato utilizzando un reticolo basato sul powerset delle tracce:
\[ \langle \wp(X^\infty), \subseteq, \cup, \cap \rangle \]
L'obiettivo è calcolare questo insieme per catturare sia le esecuzioni che terminano correttamente, sia quelle che divergono (loop infiniti).

\subsection{Calcolo tramite Least Fixpoint (lfp)}

La semantica del programma $P$ si calcola cercando il \textbf{Least Fixpoint} della sua funzione di transizione $F_P$. Utilizzando il Teorema di Kleene, procediamo in modo iterativo partendo dal basso :

\[ lfp(F_P) = \bigcup_{n \in \mathbb{N}} F_P^n(\bot) \]

\noindent \textbf{La procedura iterativa:}
L'iterazione costruisce la semantica passo dopo passo:
\begin{enumerate}
    \item \textbf{Passo 0 ($F^0(\bot) = \bot$):} Stato vuoto o non inizializzato.
    \item \textbf{Passo 1 ($F^1(\bot)$):} Tracce di lunghezza 1 (stati iniziali).
    \item \textbf{Passo $k$ ($F^k(\bot)$):} Insieme delle esecuzioni parziali di lunghezza fino a $k$.
\end{enumerate}

Il processo termina quando si raggiunge un punto fisso, ovvero quando l'aggiunta di un nuovo passo non scopre nuove tracce ($F^{k+1} = F^k$).

\vspace{1cm}

\noindent \textbf{Rappresentazione Grafica delle Tracce:}

\begin{center}
\begin{tikzpicture}[x=1.5cm, y=1cm]
    \draw[->] (0,0) -- (6,0) node[right] {Tempo discreto ($t$)};
    \draw[->] (0,0) -- (0,3.5) node[above] {Stato $x(t)$};

    \node[circle, fill=mygreen, inner sep=1.5pt, label=left:\textcolor{mygreen}{Inizio}] (s0) at (0,1) {};
    \node[circle, fill=mygreen, inner sep=1.5pt] (s1) at (1,1.5) {};
    \node[circle, fill=mygreen, inner sep=1.5pt] (s2) at (2,1.2) {};
    \node[circle, fill=mygreen, inner sep=1.5pt, label=right:\textcolor{mygreen}{Fine}] (s3) at (3,0.5) {};
    \draw[->, thick, mygreen] (s0) -- (s1) -- (s2) -- (s3);
    \node[mygreen] at (3.5, 1) {\small Traccia Finita};

    \node[circle, fill=myred, inner sep=1.5pt, label=left:\textcolor{myred}{Inizio}] (i0) at (0,2.5) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i1) at (1,2.2) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i2) at (2,2.8) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i3) at (3,2.5) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i4) at (4,2.9) {};
    \node (i_inf) at (5.5, 2.7) {\dots};
    \draw[->, thick, myred] (i0) -- (i1) -- (i2) -- (i3) -- (i4) -- (i_inf);
    \node[myred] at (4, 3.2) {\small Traccia Infinita (Loop)};

    \foreach \x in {0,1,2,3,4,5}
        \draw (\x, 0.1) -- (\x, -0.1) node[below] {\x};

\end{tikzpicture}
\end{center}
\newpage

% --- Nuove Definizioni per il Capitolo ---
\definecolor{bg_gray}{RGB}{245, 245, 245}

\newtheorem{esempio}{Esempio}[section]

\newenvironment{spiegazione}
{\vspace{0.2cm}\noindent\textbf{\textcolor{mygreen}{In parole semplici:}}\itshape}
{\vspace{0.2cm}}

\newcommand{\examquestion}[1]{
    \begin{center}
    \fcolorbox{myred}{bg_gray}{
        \parbox{0.9\textwidth}{
            \textbf{\textcolor{myred}{Possibile domanda d'esame:}}\\
            #1
        }
    }
    \end{center}
}

\section{Panoramica di un Analizzatore Statico}

Un analizzatore statico è un software complesso composto da diversi moduli che lavorano insieme per trasformare il codice sorgente in risultati di analisi (come la segnalazione di bug o garanzie di correttezza).

\subsection{Componenti Principali}

Il flusso di lavoro di un analizzatore statico segue questi passaggi logici:

\begin{enumerate}
    \item \textbf{Programma (Input):} Il codice sorgente che si vuole analizzare.
    \item \textbf{IR (Rappresentazione Interna):} Il codice viene tradotto in una forma intermedia (es. Control Flow Graph) più facile da manipolare per l'analisi.
    \item \textbf{Engine di Analisi:} Il "cuore" del sistema. Gestisce l'algoritmo di punto fisso, la risoluzione delle chiamate a funzione e la gestione della memoria.
    \item \textbf{Dominio Astratto:} L'astrazione dei dati su cui lavora l'algoritmo (es. Intervalli, Segni, Costanti).
    \item \textbf{Risultato:} L'output dell'analisi (warnings, report).
\end{enumerate}

\begin{spiegazione}
L'idea fondamentale è la \textbf{modularità}. Se vuoi analizzare un nuovo linguaggio (es. passare da Java a C++) o cambiare il tipo di analisi (es. da intervalli a segni), non devi riscrivere tutto. I componenti devono essere indipendenti: l'algoritmo di punto fisso non deve sapere che linguaggio stai analizzando, deve solo lavorare sul grafo astratto (IR).
\end{spiegazione}

\begin{center}
    \includegraphics[width=0.8\textwidth]{static_analyzer.png}
\end{center}

\examquestion{Quali sono i componenti principali di un analizzatore statico e perché è importante che siano modulari?}

\newpage

\section{LiSA (Library for Static Analysis)}

\textbf{LiSA} è una libreria open-source scritta in Java per costruire analizzatori statici basati sull'Interpretazione Astratta.

\subsection{Architettura e Flusso di Lavoro}

In LiSA, il processo di analisi avviene attraverso i seguenti step:

\begin{enumerate}
    \item \textbf{Front-end:} Un componente specifico per ogni linguaggio (Java, C, IMP, ecc.) traduce il codice sorgente nei CFG (Control Flow Graphs) di LiSA.
    \item \textbf{LiSA Core:} Il motore di analisi generico che prende i CFG e li analizza. Include:
    \begin{itemize}
        \item \textbf{CFG Fixpoint:} L'algoritmo che calcola il punto fisso sul grafo.
        \item \textbf{Statement Semantics:} La logica per interpretare le istruzioni.
        \item \textbf{Domain:} L'implementazione dei domini astratti (es. Intervalli).
        \item \textbf{Memory Handling:} La gestione della memoria (heap, stack).
    \end{itemize}
    \item \textbf{Checks:} Controlli finali sui risultati per generare warnings.
\end{enumerate}

\subsubsection*{Approfondimento: La Metafora della Catena di Montaggio}

Immagina LiSA come una \textbf{catena di montaggio universale} per analizzare programmi. Il suo obiettivo è prendere codice scritto in lingue diverse (Java, C, Python) e capire se è corretto, usando sempre lo stesso "macchinario" centrale.

Ecco la spiegazione dettagliata dei tre step:

\paragraph{1. Front-end: Il Traduttore Universale}
Il problema principale dell'analisi statica è che ogni linguaggio di programmazione ha una sintassi diversa. Scrivere un analizzatore per Java e uno per C richiederebbe di riscrivere tutto da zero due volte.

\begin{itemize}
    \item \textbf{Cosa fa:} Il Front-end agisce come un interprete. Prende il codice sorgente (il file \texttt{.java} o \texttt{.c}) e lo traduce in un linguaggio che LiSA capisce: il \textbf{CFG (Control Flow Graph)}.
    \item \textbf{Perché è utile:} Una volta che il codice è diventato un CFG di LiSA, il resto dell'analizzatore non deve più preoccuparsi se l'originale era Java o C. Vede solo nodi (istruzioni) e archi (flusso).
\end{itemize}

\paragraph{2. LiSA Core: Il Motore di Analisi}
Questo è il cervello del sistema. Una volta ricevuto il CFG "tradotto", il Core deve eseguirlo in modo astratto per trovare le proprietà del programma. È composto da quattro pezzi fondamentali che lavorano insieme:

\begin{itemize}
    \item \textbf{A. CFG Fixpoint (L'Algoritmo):} Immagina questo componente come il \textbf{direttore dei lavori}.
    \begin{itemize}
        \item Il suo compito è percorrere il grafo (CFG) e propagare le informazioni da un nodo all'altro.
        \item Usa un algoritmo iterativo (basato sulla \textit{worklist}). Continua a far girare le informazioni nel grafo finché queste non si stabilizzano (raggiungono il \textit{punto fisso}), cioè finché non cambiano più.
    \end{itemize}

    \item \textbf{B. Statement Semantics (Il Dizionario dei Significati):} Il grafo contiene istruzioni generiche. Questo componente spiega al motore \textit{cosa} significano quelle istruzioni.
    \begin{itemize}
        \item \textit{Esempio:} Se nel grafo c'è un nodo che dice \texttt{x = a + b}, la \textit{Statement Semantics} dice: "Attenzione, questo simbolo \texttt{+} significa 'somma aritmetica', non concatenazione". Traduce la sintassi in un'operazione logica che il dominio può capire.
    \end{itemize}

    \item \textbf{C. Domain (La Lente di Ingrandimento):} Questo è il componente che decide \textbf{cosa} stiamo osservando dei dati.
    \begin{itemize}
        \item Il motore chiede: "Ho la variabile \texttt{x}, come la rappresento?".
        \item Se il Dominio è \textbf{Intervalli}, risponde: "Rappresentala come \texttt{[min, max]}".
        \item Se il Dominio è \textbf{Segni}, risponde: "Dimmi solo se è \texttt{+} o \texttt{-}".
        \item È qui che avvengono i calcoli veri (es. \texttt{[1, 5] + [2, 3] = [3, 8]}).
    \end{itemize}

    \item \textbf{D. Memory Handling (La Mappa):} Questo componente gestisce \textbf{dove} sono salvati i dati.
    \begin{itemize}
        \item In un programma reale, abbiamo variabili locali (nello stack) e oggetti dinamici (nello heap).
        \item LiSA deve sapere che la variabile \texttt{x} in una funzione è diversa dalla variabile \texttt{x} in un'altra, o che \texttt{p.val} si riferisce a una specifica cella di memoria. Il \textit{Memory Handling} trasforma nomi complessi in indirizzi astratti univoci.
    \end{itemize}
\end{itemize}

\paragraph{3. Checks: L'Ispettore Finale}
Una volta che il Core ha finito di girare, abbiamo un grafo "decorato": ogni punto del programma ha associato uno stato astratto (es. "qui \texttt{x} vale \texttt{[0, 10]}").

\begin{itemize}
    \item \textbf{Cosa fa:} I \textit{Checks} scorrono questi risultati e verificano se violano delle regole.
    \item \textbf{Esempio:} Se c'è un'istruzione \texttt{y = 10 / x} e l'analisi ha calcolato che in quel punto \texttt{x} vale \texttt{[0, 5]}, il Check vede che lo \texttt{0} è incluso nell'intervallo e lancia un allarme (Warning): "Possibile divisione per zero!".
\end{itemize}

\begin{esempio}[\textbf{Riassunto pratico}]
Immagina di analizzare \texttt{x = 10 / y}:
\begin{enumerate}
    \item \textbf{Front-end:} Legge il file e crea un grafo con un nodo per la divisione.
    \item \textbf{LiSA Core:}
    \begin{itemize}
        \item \textbf{Fixpoint:} Arriva al nodo della divisione portandosi dietro le informazioni precedenti.
        \item \textbf{Memory:} Capisce quale \texttt{x} e quale \texttt{y} stiamo usando.
        \item \textbf{Semantics:} Capisce che \texttt{/} è una divisione matematica.
        \item \textbf{Domain:} Calcola il risultato astratto (es. \texttt{Intervallo(10) / Intervallo(y)}).
    \end{itemize}
    \item \textbf{Checks:} Controlla se il divisore \texttt{y} poteva essere \texttt{0}. Se sì, ti avvisa.
\end{enumerate}
\end{esempio}

\subsection{Struttura del CFG in LiSA}

Un Control Flow Graph in LiSA è costituito da:
\begin{itemize}
    \item \textbf{Nodi:} Rappresentano gli statement (istruzioni) del programma.
    \item \textbf{Archi:} Collegano i nodi e rappresentano il flusso. Possono essere:
    \begin{itemize}
        \item \textbf{Sequential Edge:} Flusso normale sequenziale.
        \item \textbf{True Edge:} Preso quando una condizione è vera (ramo \texttt{then}).
        \item \textbf{False Edge:} Preso quando una condizione è falsa (ramo \texttt{else}).
    \end{itemize}
\end{itemize}

\begin{spiegazione}
Usare i CFG permette a LiSA di "dimenticare" la sintassi specifica del linguaggio originale (es. come si scrive un ciclo \texttt{while} in C vs Python) e lavorare su una struttura a grafo unificata.
\end{spiegazione}

\examquestion{Descrivere i tipi di archi presenti in un CFG di LiSA e la loro funzione.}

\newpage

\section{Sintassi vs Semantica}

Un concetto chiave in LiSA è la distinzione tra lo statement sintattico e il suo significato semantico.

\begin{definizione}[\textbf{Rewriting Semantico}]
Diverse operazioni sintattiche possono avere lo stesso significato semantico. LiSA utilizza un linguaggio interno di \textbf{Espressioni Simboliche} per uniformare queste differenze.
\end{definizione}

\textbf{Esempio:}
In Java, l'operatore \texttt{+} può significare:
\begin{itemize}
    \item Somma aritmetica: \texttt{1 + 2}
    \item Concatenazione di stringhe: \texttt{"a" + "b"}
\end{itemize}
Il dominio astratto non deve preoccuparsi della sintassi. LiSA traduce lo statement in un'espressione simbolica "atomica":
\begin{itemize}
    \item Se sono numeri $\rightarrow$ \texttt{ArithmSum}
    \item Se sono stringhe $\rightarrow$ \texttt{StringConcat}
\end{itemize}
In questo modo, il dominio astratto implementa solo la logica per \texttt{ArithmSum} o \texttt{StringConcat}, indipendentemente da come erano scritte nel codice originale.

\examquestion{Perché LiSA distingue tra lo statement sintattico e la sua semantica tramite espressioni simboliche? Fornire un esempio.}

\section{Implementazione dell'Analisi Dataflow}

LiSA fornisce un'architettura specifica per implementare analisi dataflow (come quelle viste nel Cap. 4).

\subsection{Algoritmo Generico (Worklist)}

Le analisi dataflow in LiSA sfruttano un algoritmo di punto fisso generico basato su \textbf{worklist}. L'implementazione è divisa in due classi principali per separare la logica:

\begin{itemize}
    \item \textbf{DataflowDomain:} Gestisce la logica generale del reticolo e l'operazione di Join.
    \begin{itemize}
        \item \texttt{PossibleForwardDataflowDomain}: Implementa analisi \textbf{May} (usa l'Unione $\cup$).
        \item \texttt{DefiniteForwardDataflowDomain}: Implementa analisi \textbf{Must} (usa l'Intersezione $\cap$).
    \end{itemize}
    \item \textbf{DataflowElement:} Rappresenta il singolo elemento tracciato (es. una variabile viva, un'espressione disponibile). Definisce le operazioni specifiche \textbf{Gen} e \textbf{Kill}.
\end{itemize}

\begin{spiegazione}
Questa struttura permette di implementare una nuova analisi (es. Reaching Definitions) scrivendo solo la logica di Gen/Kill nel \texttt{DataflowElement}, mentre il \texttt{DataflowDomain} gestisce automaticamente il calcolo del punto fisso e la propagazione nel grafo.
\end{spiegazione}

\textbf{Nota:} Attualmente LiSA supporta nativamente solo analisi \textbf{Forward}.

\newpage

\section{Perché Approssimare?}

La verifica del software ha un problema fondamentale: il \textbf{Teorema di Rice}. Esso afferma che qualsiasi proprietà non banale (interessante) del comportamento di un programma è \textbf{indecidibile}.

\begin{spiegazione}
Non esiste e non esisterà mai un programma che possa prendere un qualsiasi codice e dirti con certezza assoluta "Sì, è corretto" o "No, ha un bug" in tempo finito. Se vogliamo un'analisi automatica che termini sempre, dobbiamo rinunciare alla perfezione e accettare l'\textbf{approssimazione}.
\end{spiegazione}

\subsection{Soundness e Decidibilità}

L'obiettivo dell'analisi statica è trovare un'approssimazione $\llbracket P \rrbracket^\sharp$ della semantica reale $\llbracket P \rrbracket$ che soddisfi due requisiti:

\begin{enumerate}
    \item \textbf{Soundness (Correttezza):} $\llbracket P \rrbracket \subseteq \llbracket P \rrbracket^\sharp$. L'approssimazione deve includere \textit{tutti} i comportamenti reali (anche a costo di includerne alcuni che non esistono).
    \item \textbf{Decidibilità:} Verificare le proprietà sull'approssimazione deve essere possibile in tempo finito.
\end{enumerate}

\section{Astrazione: Oggetti e Proprietà}

L'astrazione è il processo di sostituire oggetti concreti con descrizioni semplificate (proprietà).

\subsection{Reticolo delle Proprietà}

Nel mondo concreto, una proprietà è semplicemente un \textbf{insieme di oggetti} che la soddisfano.
Esempio: La proprietà "essere pari" è l'insieme $\{ \dots, -2, 0, 2, 4, \dots \}$.

\begin{definizione}[\textbf{Reticolo delle Proprietà}]
L'insieme di tutte le possibili proprietà $\wp(\Sigma)$ forma un reticolo completo dove:
\begin{itemize}
    \item L'ordine parziale $\subseteq$ è l'implicazione logica.
    \item Il Join $\cup$ è l'unione (disgiunzione logica).
    \item Il Meet $\cap$ è l'intersezione (congiunzione logica).
    \item $\top = \Sigma$ (Vero/Tutto), $\bot = \emptyset$ (Falso/Impossibile).
\end{itemize}
\end{definizione}

\newpage

\section{Direzione dell'Astrazione}

Quando approssimiamo un insieme concreto $P$ con un insieme astratto $P^\sharp$, possiamo sbagliare "per eccesso" o "per difetto".

\subsection{1. Approssimazione dal Basso (Under-Approximation)}
\[ P^\sharp \subseteq P \]
L'insieme astratto è più piccolo del reale.
\begin{itemize}
    \item Se $x \in P^\sharp \implies$ Sicuramente $x \in P$ (**YES**).
    \item Se $x \notin P^\sharp \implies$ Non so (**Don't Know**).
\end{itemize}
\textbf{Uso:} Testing e Bug Finding. Se trovo un bug nell'astrazione, il bug esiste davvero. Non posso garantire la sicurezza (potrei mancare dei bug fuori da $P^\sharp$).

\subsection{2. Approssimazione dall'Alto (Over-Approximation)}
\[ P \subseteq P^\sharp \]
L'insieme astratto è più grande del reale (include comportamenti "spuri").
\begin{itemize}
    \item Se $x \notin P^\sharp \implies$ Sicuramente $x \notin P$ (**NO** - Sicuro).
    \item Se $x \in P^\sharp \implies$ Potrebbe essere vero o un Falso Positivo (**Don't Know**).
\end{itemize}
\textbf{Uso:} \textbf{Safety Verification} (Analisi Statica classica). Se l'astrazione dice "nessun errore", il programma è sicuro. Se segnala un errore, potrebbe essere un falso allarme.

\begin{center}
\begin{tikzpicture}
    % Under
    \draw[fill=gray!20] (0,0) circle (1.5cm);
    \node at (0, 1.8) {Concreto $P$};
    \draw[fill=mygreen!30] (0,0) circle (0.8cm);
    \node at (0,0) {$P^\sharp \subseteq P$};
    \node at (0, -2) {\textbf{Dal Basso (Bug Finding)}};

    % Over
    \begin{scope}[xshift=5cm]
    \draw[fill=myred!20] (0,0) circle (2cm);
    \node at (0, 2.2) {Astratto $P^\sharp$};
    \draw[fill=gray!50] (0,0) circle (1.2cm);
    \node at (0,0) {$P \subseteq P^\sharp$};
    \node at (0, -2) {\textbf{Dall'Alto (Safety)}};
    \end{scope}
\end{tikzpicture}
\end{center}

\examquestion{Qual è la differenza tra approssimazione dal basso e dall'alto? Quale delle due garantisce la "Soundness" per la verifica di sicurezza e perché?}

\newpage

\section{Esempio: Il Dominio dei Segni}

Un esempio classico di astrazione dall'alto per i numeri interi.

\begin{definizione}[\textbf{Dominio dei Segni}]
Il dominio astratto è $D^\sharp = \{ \bot, (-), (0), (+), \top \}$.
\begin{itemize}
    \item $\alpha(\{1, 5, 100\}) = (+)$
    \item $\alpha(\{-5, 2\}) = \top$ (Non so il segno, contiene sia positivi che negativi).
\end{itemize}
\end{definizione}

\noindent \textbf{Perdita di precisione:}
Le operazioni devono essere ridefinite per mantenere la soundness.
\begin{itemize}
    \item $(+) +^\sharp (+) = (+)$ (Preciso).
    \item $(+) +^\sharp (-) = \top$ (Impreciso: $5 + (-2) > 0$, ma $2 + (-5) < 0$. Non possiamo saperlo).
\end{itemize}

\section{Gerarchia delle Semantiche}

L'analisi statica può essere vista come una serie di astrazioni successive, partendo dalla realtà più dettagliata fino a quella più astratta.

\subsection{1. Semantica delle Tracce (Trace Semantics)}
È la realtà completa. Una traccia è una sequenza di stati nel tempo (es. $x_0 \to x_1 \to x_2 \dots$). Distingue ogni singola esecuzione e l'ordine temporale degli eventi. È incalcolabile.

\subsection{2. Semantica Collettrice (Collecting Semantics)}
\textbf{Astrazione:} Dimentichiamo l'ordine temporale e le relazioni tra stati successivi.
Per ogni punto del programma (riga di codice), raccogliamo l'insieme di \textbf{tutti} i possibili stati che possono verificarsi lì, indipendentemente da come ci siamo arrivati.

\begin{spiegazione}
Immagina di scattare una foto a tutte le possibili variabili ogni volta che il programma passa per la riga 10. Mettiamo tutti questi valori in un sacco. Perdiamo la storia ("ci sono arrivato dopo il ciclo o prima?"), ma sappiamo quali valori sono possibili. Questo introduce "rumore" o tracce spurie.
\end{spiegazione}

\subsection{3. Semantica Astratta (Abstract Semantics)}
\textbf{Astrazione:} Sostituiamo gli insiemi di stati (che possono essere infiniti o complessi) con oggetti geometrici o logici calcolabili (Intervalli, Segni, Poliedri).

\examquestion{Cosa si intende per Semantica Collettrice e quale informazione si perde passando dalla Semantica delle Tracce a quest'ultima?}

\noindent\textbf{Risposta:}

La Semantica Collettrice associa ad ogni punto del programma (es. riga di codice o nodo del CFG) l'insieme di tutti gli stati di memoria raggiungibili in quel punto in qualsiasi possibile esecuzione. Matematicamente, dimentica la dimensione temporale $t$ e proietta gli stati sulla struttura del programma (i punti di controllo).

\vspace{0.3cm}
\noindent\textbf{Quale informazione si perde?}

Passando dalla Semantica delle Tracce a quella Collettrice si perde l'ordine temporale e le relazioni tra stati successivi.

\begin{itemize}
    \item \textbf{Perdita della Storia:} Non sappiamo più "da dove veniamo". Se lo stato $S_1$ e lo stato $S_2$ sono entrambi possibili alla riga $L$, la semantica collettrice non ci dice se $S_1$ appare sempre prima di $S_2$ o viceversa.
    \item \textbf{Tracce Spurie (Rumore):} Poiché perdiamo il legame causa-effetto tra uno stato e il successivo, l'analisi potrebbe ammettere dei cammini "fantasma" (\textit{spurious traces}) che saltano da uno stato valido all'altro in modi che nella realtà non avvengono mai (es. saltare dallo stato dell'iterazione 10 allo stato dell'iterazione 2).
\end{itemize}

\newpage

\section{Il Ponte tra Concreto e Astratto}

Per analizzare un programma, dobbiamo muoverci tra due mondi:
\begin{enumerate}
    \item \textbf{Dominio Concreto ($C$):} La realtà precisa ma incalcolabile. Esempio: l'insieme dei numeri interi $\wp(\mathbb{Z})$.
    \item \textbf{Dominio Astratto ($A$):} La semplificazione calcolabile. Esempio: il dominio dei Segni o degli Intervalli.
\end{enumerate}

Per passare da un mondo all'altro senza fare errori logici, usiamo due funzioni speciali chiamate $\alpha$ e $\gamma$.

\subsection{Le Funzioni $\alpha$ e $\gamma$}

\begin{definizione}[\textbf{Astrazione} $\alpha$]
$\alpha: C \to A$. Dato un insieme di valori concreti, restituisce il valore astratto "migliore" che li descrive.
\[ \alpha(\{1, 2, 5\}) = [1, 5] \quad (\text{negli Intervalli}) \]
\end{definizione}

\begin{definizione}[\textbf{Concretizzazione} $\gamma$]
$\gamma: A \to C$. Dato un valore astratto, restituisce l'insieme di \textbf{tutti} i valori concreti che esso rappresenta.
\[ \gamma([1, 5]) = \{1, 2, 3, 4, 5\} \]
\end{definizione}

\begin{spiegazione}
Nota che $\gamma$ restituisce $\{1, 2, 3, 4, 5\}$ anche se l'insieme originale era solo $\{1, 2, 5\}$. I numeri $3$ e $4$ sono "rumore" o approssimazione introdotta dall'astrazione. Non possiamo evitarlo se vogliamo semplificare.
\end{spiegazione}

\section{Connessione di Galois (GC)}

Una Connessione di Galois è la formalizzazione matematica che garantisce che $\alpha$ e $\gamma$ siano "sincronizzate" correttamente per garantire la \textbf{Soundness} (sicurezza).

\begin{definizione}[\textbf{Connessione di Galois}]
Due posets $\langle C, \subseteq \rangle$ e $\langle A, \sqsubseteq \rangle$ formano una Connessione di Galois $(\alpha, \gamma)$ se valgono due proprietà:

\begin{enumerate}
    \item \textbf{$\gamma \circ \alpha$ è Estensiva:} $\forall c \in C, \quad c \subseteq \gamma(\alpha(c))$
    \item \textbf{$\alpha \circ \gamma$ è Riduttiva:} $\forall a \in A, \quad \alpha(\gamma(a)) \sqsubseteq a$
\end{enumerate}
Inoltre, entrambe le funzioni devono essere \textbf{monotone} (preservare l'ordine).
\end{definizione}

\subsection{Spiegazione Intuitiva delle Proprietà}

\textbf{1. Estensività ($\gamma \circ \alpha \supseteq Id$): "Non perdere la verità"}
Se prendo i dati reali ($c$), li astraggo ($\alpha$) e poi torno indietro al concreto ($\gamma$), l'insieme che ottengo deve \textbf{contenere} i dati di partenza.
\begin{itemize}
    \item $c = \{1, 5\}$
    \item $\alpha(c) = [1, 5]$
    \item $\gamma([1, 5]) = \{1, 2, 3, 4, 5\}$
\end{itemize}
$\{1, 5\} \subseteq \{1, 2, 3, 4, 5\}$. La proprietà è rispettata. Se mancasse il 5, l'analisi sarebbe sbagliata (unsound).

\textbf{2. Riduttività ($\alpha \circ \gamma \sqsubseteq Id$): "Non perdere precisione inutilmente"}
Se parto da un'astrazione ($a$), la concretizzo ($\gamma$) e poi la ri-astraggo ($\alpha$), non devo ottenere un'astrazione peggiore (più grande) di quella di partenza.
\begin{itemize}
    \item $a = [1, 5]$
    \item $\gamma(a) = \{1, 2, 3, 4, 5\}$
    \item $\alpha(\{1, \dots, 5\}) = [1, 5]$
\end{itemize}
$[1, 5] \sqsubseteq [1, 5]$. Sono uguali, quindi la proprietà è rispettata.

\begin{center}
\begin{tikzpicture}
    % Left side (Concrete)
    \draw (0,0) ellipse (1.2cm and 2cm);
    \node at (0, 2.5) {Concreto $C$};
    \node (c) at (0,0) {$\bullet$};
    \node [below] at (c) {$c$};
    
    % Right side (Abstract)
    \draw (6,0) ellipse (1.2cm and 2cm);
    \node at (6, 2.5) {Astratto $A$};
    \node (a) at (6,0) {$\bullet$};
    \node [below] at (a) {$a$};

    % Arrows
    \draw[->, bend left, thick, blue] (c) to node[above] {$\alpha$} (a);
    \draw[->, bend left, thick, red] (a) to node[below] {$\gamma$} (c);
    
    % Property text
    \node at (3, -3) {$\alpha(c) \sqsubseteq a \iff c \subseteq \gamma(a)$};
\end{tikzpicture}
\end{center}

\newpage

\section{Galois Insertion (GI)}

Spesso nel dominio astratto ci sono elementi "inutili" o ridondanti. Quando li rimuoviamo tutti, otteniamo una forma speciale di connessione.

\begin{definizione}[\textbf{Galois Insertion}]
Una Connessione di Galois è una \textbf{Insertion} se $\alpha \circ \gamma$ è l'\textbf{Identità}:
\[ \forall a \in A, \quad \alpha(\gamma(a)) = a \]
\end{definizione}

\begin{spiegazione}
Significa che ogni elemento del dominio astratto rappresenta un insieme di valori concreti unico. Non ci sono due etichette diverse per dire la stessa cosa.
Esempio: Se avessi nel dominio astratto sia $[1, 2]$ che un simbolo speciale $K$ che vuol dire "intervallo tra 1 e 2", $\gamma$ mapperebbe entrambi a $\{1, 2\}$. Ri-astraendo $\{1, 2\}$ però $\alpha$ dovrebbe sceglierne uno solo. Se $\alpha(\gamma(K)) = [1, 2] \neq K$, non è una Insertion.
\end{spiegazione}

\section{Best Abstraction (Migliore Astrazione)}

Una proprietà fondamentale garantita dalle Connessioni di Galois è l'esistenza della \textbf{Best Abstraction}.

\begin{definizione}
Per ogni insieme concreto $c \in C$, l'elemento $\alpha(c)$ è la \textbf{migliore} (più precisa) approssimazione possibile di $c$ nel dominio $A$.
\[ \forall a \in A, \quad c \subseteq \gamma(a) \implies \alpha(c) \sqsubseteq a \]
\end{definizione}

\subsection{Quando la Best Abstraction non esiste?}
Ci sono casi in cui non possiamo costruire una Connessione di Galois perché manca l'elemento "migliore".

\textbf{Esempio: Il Cerchio e i Poliedri.}
Immagina di voler astrarre un \textbf{cerchio} usando dei \textbf{poliedri} (figure con lati dritti, come quadrati, esagoni, ecc.).
\begin{itemize}
    \item Puoi racchiudere il cerchio in un quadrato.
    \item Puoi racchiuderlo in un ottagono (più preciso).
    \item Puoi usare un poligono a 100 lati (ancora più preciso).
\end{itemize}
Non esiste un "poliedro più piccolo possibile" che contiene il cerchio, perché puoi sempre tagliarne un pezzetto in più aggiungendo un lato.
Quindi, tra il dominio delle figure geometriche curve e quello dei poliedri \textbf{non esiste una Connessione di Galois}.

\examquestion{Spiegare la differenza tra Galois Connection e Galois Insertion. Fornire un esempio intuitivo di quando la proprietà di riduttività ($\alpha \circ \gamma \sqsubseteq Id$) diventa un'uguaglianza.}

\newpage

\section{Semantica Astratta sui Control Flow Graphs (CFG)}

Fino ad ora abbiamo visto la semantica concreta (le tracce di esecuzione). Per l'analisi statica vera e propria, è più comodo ragionare direttamente sul \textbf{Control Flow Graph (CFG)}.

\subsection{Stati di Ingresso e Uscita}

Dato un CFG, per ogni nodo (o punto del programma) $x_i$, vogliamo calcolare due insiemi di stati:

\begin{itemize}
    \item \textbf{Entry State (Stato di Ingresso):} È lo stato della memoria \textit{prima} che l'istruzione del nodo venga eseguita. Si calcola unendo (Join/LUB) gli stati di uscita di tutti i nodi predecessori.
    \[ entry(x_i) = \bigsqcup \{ exit(x_j) \mid x_j \to x_i \} \]
    \item \textbf{Exit State (Stato di Uscita):} È il risultato dell'applicazione della semantica (astratta o concreta) dell'istruzione allo stato di ingresso.
    \[ exit(x_i) = \llbracket \text{stmt}(x_i) \rrbracket (entry(x_i)) \]
\end{itemize}

\begin{spiegazione}
Immagina il CFG come una rete di tubi. L'acqua (i dati) scorre da un nodo all'altro. In ogni nodo, l'acqua che entra è la miscela di tutta l'acqua che arriva dai tubi precedenti. Il nodo poi "tratta" l'acqua (esegue l'istruzione) e la manda fuori.
\end{spiegazione}

\section{Sistemi di Equazioni e Punto Fisso}

L'analisi statica si riduce a risolvere un sistema di equazioni ricorsive.

\begin{definizione}[\textbf{Sistema di Equazioni Semantiche}]
Dato un CFG con $m$ nodi, il sistema è definito come:
\[ F = \{ x_i = f_i(x_1, \dots, x_m) \mid i = 1, \dots, m \} \]
dove ogni $x_i$ rappresenta lo stato associato al nodo $i$ e $f_i$ è la funzione che calcola tale stato basandosi sugli altri.
\end{definizione}

L'obiettivo è trovare la \textbf{Soluzione Minima} (Least Fixpoint) di questo sistema.
\begin{itemize}
    \item Nel dominio concreto $\wp(\mathbb{Z})$, calcolare questo punto fisso è spesso \textbf{indecidibile} o richiede tempo infinito.
    \item Ecco perché passiamo al dominio astratto.
\end{itemize}

\section{Approssimazione e Soundness}

Poiché non possiamo calcolare il punto fisso concreto, introduciamo un dominio astratto $A$ che approssima il concreto $C$.

\subsection{Soundness della Funzione Astratta}

Affinché l'analisi sia affidabile, la funzione astratta $f^\sharp$ deve essere una \textbf{Sound Abstraction} della funzione concreta $f$.

\begin{definizione}[\textbf{Soundness}]
Siano $C$ e $A$ legati da una connessione di Galois $(\alpha, \gamma)$. Una funzione $f^\sharp: A \to A$ è sound rispetto a $f: C \to C$ se:
\[ \forall c \in C, \quad \alpha(f(c)) \sqsubseteq_A f^\sharp(\alpha(c)) \]
\textit{Oppure equivalentemente:}
\[ \forall a \in A, \quad f(\gamma(a)) \sqsubseteq_C \gamma(f^\sharp(a)) \]
\end{definizione}

\begin{spiegazione}
Significa che l'operazione astratta non deve mai essere "più ottimista" della realtà. Se nella realtà $2+2=4$, la mia somma astratta deve dire "il risultato è positivo" o "è pari", non può dire "è negativo". Deve includere la verità.
\end{spiegazione}

\section{Teoremi di Trasferimento del Punto Fisso}

Una volta definito il sistema astratto, due teoremi ci garantiscono che il risultato che calcoleremo sarà corretto rispetto al programma reale.

\subsection{Teorema di Approssimazione di Kleene}
Se la funzione astratta è \textbf{continua}, possiamo calcolare il punto fisso iterando la funzione partendo dal basso ($\bot$). Il limite della sequenza è un'approssimazione corretta.
\[ lfp(f) \sqsubseteq \gamma(\text{limite iterazioni astratte}) \]

\subsection{Teorema di Approssimazione di Tarski}
Questo è più generale (richiede solo la \textbf{monotonia}). Afferma che qualsiasi \textbf{post-fixpoint} astratto è un'approssimazione sicura.

\begin{teorema}[\textbf{Approssimazione di Tarski}]
Se $a$ è un post-fixpoint di $f^\sharp$ (cioè $f^\sharp(a) \sqsubseteq a$), allora:
\[ lfp(f) \sqsubseteq \gamma(a) \]
\end{teorema}

\begin{spiegazione}
Questo teorema è potentissimo. Ci dice che non serve trovare \textit{esattamente} il punto fisso minimo astratto (che potrebbe essere difficile). Basta trovare un punto "stabile" dove $f^\sharp(a)$ è più piccolo o uguale ad $a$. Qualsiasi punto stabile è una garanzia di sicurezza per il programma reale.
\end{spiegazione}

\examquestion{Enunciare il Teorema di Approssimazione di Tarski e spiegare perché è fondamentale per la terminazione dell'analisi statica (suggerimento: widening).}

\newpage

\section{Il Problema del Filter (Assume)}

Nell'analisi statica classica, quando il programma incontra una diramazione condizionale (es. \texttt{if (x > 0)}), l'analizzatore deve dividere il flusso in due rami:
\begin{enumerate}
    \item Il ramo \textbf{True}, dove assumiamo che $x > 0$.
    \item Il ramo \textbf{False}, dove assumiamo che $x \le 0$ (la negazione).
\end{enumerate}

Tradizionalmente, questo viene fatto usando l'operatore \texttt{filter} (o \texttt{assume}).

\begin{definizione}[\textbf{Filter Operator}]
\[ \text{filter}: A \times \text{Pred} \to A \]
Dato uno stato astratto $A$ e un predicato $c$, restituisce un nuovo stato astratto raffinato in cui $c$ è vero.
\end{definizione}

\subsection{Inefficienze dell'approccio classico}
Per gestire un \texttt{if}, l'analizzatore deve fare queste operazioni:
1.  \textbf{Copia:} Duplicare lo stato astratto $A$ in memoria (perché serve sia per il ramo True che per il False).
2.  \textbf{Filter Positivo:} Calcolare \texttt{filter}$(A, c)$.
3.  \textbf{Filter Negativo:} Calcolare \texttt{filter}$(A, \neg c)$.

\begin{spiegazione}
Immagina di dover dividere un mazzo di carte in "Rosse" e "Nere".
L'approccio classico è:
1. Fai una fotocopia dell'intero mazzo.
2. Sul mazzo originale, scorri e butta via le Nere (tieni le Rosse).
3. Sulla fotocopia, scorri e butta via le Rosse (tieni le Nere).
È uno spreco! Hai duplicato il lavoro e lo spazio.
\end{spiegazione}

\section{L'Operatore Split}

Per risolvere queste inefficienze, è stato introdotto l'operatore \textbf{Split}.

\begin{definizione}[\textbf{Split Operator}]
L'operatore split è una funzione che processa il vincolo e la sua negazione in un unico passaggio atomico:
\[ \text{split}: A \times \text{Pred} \to A \times A \]
Prende in input uno stato astratto e un predicato, e restituisce una \textbf{coppia} di stati: $(A_{true}, A_{false})$.
\end{definizione}

\subsection{Vantaggi dello Split}
L'uso di \texttt{split} porta due grandi vantaggi:
\begin{itemize}
    \item \textbf{Eliminazione del lavoro duplicato:} Il dominio astratto (es. Poliedri) può calcolare le due uscite simultaneamente, riutilizzando i calcoli intermedi.
    \item \textbf{Gestione della memoria:} Non serve copiare esplicitamente lo stato astratto prima dell'operazione. La gestione della memoria è delegata internamente alla libreria del dominio (che può essere più intelligente e fare copie "lazy" o parziali).
\end{itemize}

\begin{spiegazione}
Tornando all'esempio delle carte: lo Split prende il mazzo e, in un solo passaggio, sposta le Rosse a sinistra e le Nere a destra. Nessuna fotocopia inutile, nessun doppio passaggio.
\end{spiegazione}

\section{Implementazione nel CFG}

L'adozione dello Split richiede una modifica strutturale al \textbf{Control Flow Graph (CFG)} usato dall'analizzatore.

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    % Standard CFG
    \node (head1) [draw, rectangle] {Entry};
    \node (cond1) [draw, diamond, aspect=2, below of=head1] {\texttt{if (cond)}};
    \node (true1) [draw, rectangle, below left=1cm and 1cm of cond1] {\texttt{assume(cond)}};
    \node (false1) [draw, rectangle, below right=1cm and 1cm of cond1] {\texttt{assume(!cond)}};
    
    \draw[->] (head1) -- (cond1);
    \draw[->] (cond1) -- node[left] {T} (true1);
    \draw[->] (cond1) -- node[right] {F} (false1);
    
    \node at (0, -4.5) {\textbf{Standard CFG (Filter)}};

    % Split CFG
    \node (head2) [draw, rectangle, right=6cm of head1] {Entry};
    \node (split) [draw, rectangle, double, below of=head2, minimum width=3cm] {\texttt{split(cond)}};
    \node (true2) [draw, rectangle, below left=1cm and 0.5cm of split] {True Branch};
    \node (false2) [draw, rectangle, below right=1cm and 0.5cm of split] {False Branch};
    
    \draw[->] (head2) -- (split);
    \draw[->] (split.south west) -- (true2);
    \draw[->] (split.south east) -- (false2);
    
    \node at (6, -4.5) {\textbf{Optimized CFG (Split)}};
\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{Approccio Classico:} Il nodo condizionale ha due archi uscenti. Su ogni arco c'è un'istruzione \texttt{assume} (filter) separata. L'analizzatore deve visitare prima un arco, poi tornare indietro, copiare lo stato e visitare l'altro.
    \item \textbf{Approccio Split:} Il nodo condizionale è sostituito da un blocco \texttt{split(cond)}. Questo blocco calcola internamente le due uscite e le propaga direttamente ai successori.
\end{itemize}

\section{Valutazione Sperimentale}

L'approccio è stato implementato in framework reali (come \textit{LiSA} o \textit{Crab}) e testato. I risultati mostrano:
\begin{itemize}
    \item \textbf{Miglioramento del tempo di analisi:} Riduzione significativa dei tempi di calcolo.
    \item \textbf{Riduzione della memoria:} Minore picco di utilizzo della RAM grazie alla gestione ottimizzata delle copie degli stati.
\end{itemize}

\examquestion{Spiegare la differenza concettuale e operativa tra l'operatore \texttt{filter} e l'operatore \texttt{split}. Perché \texttt{split} è considerato un'ottimizzazione?}

\end{document}