\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{graphicx}

\geometry{a4paper, margin=2.5cm}

\definecolor{myblue}{RGB}{0, 102, 204}
\definecolor{myred}{RGB}{204, 0, 0}
\definecolor{mygreen}{RGB}{0, 153, 76}

\usepackage{titlesec}
\titleformat{\section}
{\color{myblue}\normalfont\Large\bfseries}
{\color{myblue}\thesection}{1em}{}

\titleformat{\subsection}
{\color{myblue}\normalfont\large\bfseries}
{\color{myblue}\thesubsection}{1em}{}

\theoremstyle{definition}
\newtheorem{definizione}{Definizione}[section]

\title{\textbf{\textcolor{myblue}{Definizioni Fondamentali}}\\ \large Analisi Statica e Verifica del Software}
\author{}
\date{}

\begin{document}

\maketitle

\section{Set (Insieme)}

\begin{definizione}[\textbf{Insieme}]
Un insieme (\textit{set}) è una collezione di oggetti ben definiti e distinti. La collezione stessa è considerata un oggetto a sé stante.
\end{definizione}

Dato un insieme $S$, valgono le seguenti notazioni fondamentali:
\begin{itemize}
    \item \textbf{Appartenenza:} $s \in S$ indica che l'elemento $s$ appartiene all'insieme $S$.
    \item \textbf{Sottoinsieme:} $S_1 \subseteq S_2 \iff \forall s \in S_1 \Rightarrow s \in S_2$.
    \item \textbf{Unione:} $S_1 \cup S_2 = \{s \mid s \in S_1 \vee s \in S_2\}$.
    \item \textbf{Intersezione:} $S_1 \cap S_2 = \{s \mid s \in S_1 \wedge s \in S_2\}$.
\end{itemize}

\section{Partial Order (Ordine Parziale)}

\begin{definizione}[\textbf{Ordine Parziale}]
Un ordine parziale è una relazione binaria $\sqsubseteq$ su un insieme $X$ che soddisfa le seguenti tre proprietà per ogni $x, y, z \in X$:
\begin{enumerate}
    \item \textbf{Riflessività:} $\forall x \in X \Rightarrow x \sqsubseteq x$.
    \item \textbf{Anti-simmetria:} $(x \sqsubseteq y \wedge y \sqsubseteq x) \Rightarrow x = y$.
    \item \textbf{Transitività:} $(x \sqsubseteq y \wedge y \sqsubseteq z) \Rightarrow x \sqsubseteq z$.
\end{enumerate}
\end{definizione}

\section{Poset (Insieme Parzialmente Ordinato)}

\begin{definizione}[\textbf{Poset}]
Un \textit{Poset} (Partially Ordered Set) è la coppia formata da un insieme $X$ e da una relazione di ordine parziale definita su di esso. Si denota formalmente come:
\[ \langle X, \sqsubseteq \rangle \]
\end{definizione}

\noindent \textbf{Esempio:} L'insieme dei numeri interi con la relazione "minore o uguale" è un poset: $\langle \mathbb{Z}, \le \rangle$.

\section{Powerset (Insieme delle Parti)}

\begin{definizione}[\textbf{Powerset}]
Dato un insieme $S$, l'insieme delle parti (\textit{powerset}) di $S$, indicato con $\wp(S)$ (o $\mathcal{P}(S)$), è l'insieme di tutti i sottoinsiemi di $S$:
\[ \wp(S) = \{ U \mid U \subseteq S \} \]
\end{definizione}

\noindent \textbf{Cardinalità:} Dato un insieme $S$ con $|S| = n$ elementi, il suo powerset ha $|\wp(S)| = 2^n$ elementi.

\noindent \textbf{Struttura di Poset:} Un powerset forma naturalmente un poset rispetto alla relazione di inclusione insiemistica: $\langle \wp(S), \subseteq \rangle$.

\newpage

\section{Bounds e Operazioni nel Powerset}

In un poset generico $\langle X, \sqsubseteq \rangle$, definiamo i concetti di limiti (bounds) per un sottoinsieme $Y \subseteq X$.

\subsection{Definizioni Astratte}

\begin{definizione}[\textbf{Upper Bound e LUB}]
\leavevmode
\begin{itemize}
    \item \textbf{Upper Bound (Maggiorante):} Un elemento $u \in X$ è un upper bound di $Y$ se è maggiore o uguale a tutti gli elementi di $Y$ ($\forall y \in Y, y \sqsubseteq u$).
    \item \textbf{Least Upper Bound (LUB o Join $\sqcup$):} È il più piccolo tra tutti gli upper bound. Se esiste, è unico.
\end{itemize}
\end{definizione}

\begin{definizione}[\textbf{Lower Bound e GLB}]
\leavevmode
\begin{itemize}
    \item \textbf{Lower Bound (Minorante):} Un elemento $l \in X$ è un lower bound di $Y$ se è minore o uguale a tutti gli elementi di $Y$ ($\forall y \in Y, l \sqsubseteq y$).
    \item \textbf{Greatest Lower Bound (GLB o Meet $\sqcap$):} È il più grande tra tutti i lower bound. Se esiste, è unico.
\end{itemize}
\end{definizione}

\subsection{Applicazione nel Powerset}

Nel caso specifico del Powerset $\langle \wp(S), \subseteq \rangle$, le operazioni astratte corrispondono alle operazioni insiemistiche classiche:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Concetto Astratto} & \textbf{Simbolo} & \textbf{Nel Powerset ($\subseteq$)} \\
\hline
Ordine Parziale & $\sqsubseteq$ & Inclusione ($\subseteq$) \\
Least Upper Bound (Join) & $\sqcup$ & \textbf{Unione ($\cup$)} \\
Greatest Lower Bound (Meet) & $\sqcap$ & \textbf{Intersezione ($\cap$)} \\
Elemento Top & $\top$ & Insieme Universo ($S$) \\
Elemento Bottom & $\bot$ & Insieme Vuoto ($\emptyset$) \\
\hline
\end{tabular}
\end{center}

\vspace{0.5cm}

\subsection{Rappresentazione Grafica (Diagramma di Hasse)}
Esempio del poset $\wp(\{a, b\})$ ordinato per inclusione.

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    \node (top) at (0,3) {$\{a, b\}$ ($\top$)};
    \node (a) at (-2,1.5) {$\{a\}$};
    \node (b) at (2,1.5) {$\{b\}$};
    \node (bot) at (0,0) {$\emptyset$ ($\bot$)};

    \draw (bot) -- (a);
    \draw (bot) -- (b);
    \draw (a) -- (top);
    \draw (b) -- (top);
    
    \node[right of=top, xshift=1cm, text width=4cm, font=\small, align=left, color=myred] {$\leftarrow$ \textbf{Upper Bound} di $\{a\}$ e $\{b\}$ (Unione)};
    \node[right of=bot, xshift=1cm, text width=4cm, font=\small, align=left, color=mygreen] {$\leftarrow$ \textbf{Lower Bound} di $\{a\}$ e $\{b\}$ (Intersezione)};
\end{tikzpicture}
\end{center}

\newpage

\section{Reticoli (Lattices)}

Un reticolo è un tipo speciale di poset "molto ordinato", in cui non ci si perde mai né salendo né scendendo.

\subsection{Lattice (Reticolo)}

\begin{definizione}[\textbf{Lattice}]
Un poset $\langle X, \sqsubseteq \rangle$ è un \textbf{Lattice} se, per \textbf{ogni coppia} di elementi $x, y \in X$, esistono sempre:
\begin{enumerate}
    \item Il loro \textbf{Join} $x \sqcup y$ (Least Upper Bound).
    \item Il loro \textbf{Meet} $x \sqcap y$ (Greatest Lower Bound).
\end{enumerate}
\end{definizione}

\noindent \textbf{Differenza visiva:}
\begin{itemize}
    \item \textbf{Join Semi-Lattice:} Converge sempre andando verso l'alto (come una V).
    \item \textbf{Meet Semi-Lattice:} Converge sempre andando verso il basso (come una $\wedge$).
    \item \textbf{Lattice:} È chiuso sia sopra che sotto (come un diamante).
\end{itemize}

\begin{center}
\begin{tikzpicture}

    \begin{scope} 
        \node at (0,0) (j1) {$\bullet$};
        \node at (1,0) (j2) {$\bullet$};
        \node at (0.5,1) (jtop) {$\bullet$};
        \draw (j1) -- (jtop);
        \draw (j2) -- (jtop);
        \node at (0.5, -0.5) {\textit{Join Semi-Lattice}};
    \end{scope}

    \begin{scope}[xshift=4cm] 
        \node at (0,1) (m1) {$\bullet$};
        \node at (1,1) (m2) {$\bullet$};
        \node at (0.5,0) (mbot) {$\bullet$};
        \draw (mbot) -- (m1);
        \draw (mbot) -- (m2);
        \node at (0.5, -0.5) {\textit{Meet Semi-Lattice}};
    \end{scope}

    \begin{scope}[xshift=8cm]
        \node at (0.5,0.5) (lbot) {$\bullet$};
        \node at (0,1.5) (l1) {$\bullet$};
        \node at (1,1.5) (l2) {$\bullet$};
        \node at (0.5,2.5) (ltop) {$\bullet$};
        \draw (lbot) -- (l1) -- (ltop) -- (l2) -- (lbot);
        \node at (0.5, -0.5) {\textit{Lattice}};
    \end{scope}

\end{tikzpicture}
\end{center}
\subsection{Set Lattice (Reticolo di Insiemi)}

È l'"istanza concreta" più comune di un reticolo.

\begin{definizione}[\textbf{Set Lattice}]
Dato un insieme $S$, il \textbf{Set Lattice} è la struttura formata dal suo powerset $\wp(S)$ equipaggiato con le operazioni insiemistiche classiche:
\[ \langle \wp(S), \subseteq, \cup, \cap \rangle \]
\end{definizione}

\noindent \textbf{Caratteristiche:}
\begin{itemize}
    \item \textbf{Dominio:} Insieme delle parti.
    \item \textbf{Join ($\sqcup$):} Unione ($\cup$).
    \item \textbf{Meet ($\sqcap$):} Intersezione ($\cap$).
\end{itemize}

\begin{center}
\begin{tikzpicture}[scale=0.8]
    \node (bot) at (0,0) {$\emptyset$};
    
    \node (n1) at (-3,1.5) {$\{-1\}$};
    \node (n0) at (0,1.5) {$\{0\}$};
    \node (p1) at (3,1.5) {$\{1\}$};
    
    \node (n10) at (-3,3) {$\{-1, 0\}$};
    \node (n1p1) at (0,3) {$\{-1, 1\}$};
    \node (n0p1) at (3,3) {$\{0, 1\}$};
    
    \node (top) at (0,4.5) {$\{-1, 0, 1\}$};

    \draw (bot) -- (n1); \draw (bot) -- (n0); \draw (bot) -- (p1);
    \draw (n1) -- (n10); \draw (n1) -- (n1p1);
    \draw (n0) -- (n10); \draw (n0) -- (n0p1);
    \draw (p1) -- (n1p1); \draw (p1) -- (n0p1);
    \draw (n10) -- (top); \draw (n1p1) -- (top); \draw (n0p1) -- (top);
    
    \node at (0, -1) {\textbf{Esempio:} Set Lattice su $\wp(\{-1,0,1\})$};
\end{tikzpicture}
\end{center}

\subsection{Complete Lattice (Reticolo Completo)}

\begin{definizione}[\textbf{Complete Lattice}]
Un reticolo è \textbf{completo} se Join ($\sqcup$) e Meet ($\sqcap$) esistono per \textbf{qualsiasi sottoinsieme} del dominio, anche infinito.
\end{definizione}

\noindent \textbf{Conseguenze importanti:}
\begin{itemize}
    \item Un reticolo completo ha sempre un elemento \textbf{Top} ($\top = \sqcup X$) e un elemento \textbf{Bottom} ($\bot = \sqcap X$).
    \item I reticoli finiti (come i Set Lattice su insiemi finiti) sono sempre completi.
    \item I numeri interi $\langle \mathbb{Z}, \le \rangle$ sono un Lattice ma \textbf{non} completo (mancano $\top$ e $\bot$). Per renderlo completo bisogna aggiungere $+\infty$ e $-\infty$.
\end{itemize}

\newpage

\section{Relazioni e Funzioni (Maps)}

Questi concetti matematici sono fondamentali per descrivere come cambiano gli stati di un programma durante l'esecuzione.

\subsection{Relazioni}

\begin{definizione}[\textbf{Relazione}]
Dati due insiemi $X$ e $Y$, una \textbf{relazione} $R$ è un sottoinsieme del prodotto cartesiano $X \times Y$:
\[ R \subseteq X \times Y \]
\end{definizione}

\noindent \textbf{Esempio:} L'ordine parziale $\sqsubseteq$ è una relazione definita su un insieme con se stesso ($R \subseteq X \times X$).

\subsection{Funzioni (Maps)}

\begin{definizione}[\textbf{Funzione}]
Una \textbf{funzione} (o mappa) $f: X \rightarrow Y$ è una relazione speciale che soddisfa la proprietà di \textbf{unicità dell'immagine}: per ogni input $x \in X$, esiste al massimo un output $y \in Y$.
\end{definizione}

\noindent Le funzioni sono usate per modellare lo stato della memoria (es. mappa \textit{variabile} $\rightarrow$ \textit{valore}).

\subsubsection{Proprietà delle Funzioni sui Poset}

Quando le funzioni operano su insiemi ordinati (Poset), ci interessano tre proprietà chiave per l'analisi statica.

\begin{definizione}[\textbf{Monotonia}]
Una funzione $f: X \rightarrow Y$ è \textbf{monotona} se preserva l'ordine:
\[ x_1 \sqsubseteq x_2 \implies f(x_1) \sqsubseteq f(x_2) \]
\textit{Intuitivamente:} Se l'input "cresce" (diventa più grande o più preciso), l'output non può "decrescere".
\end{definizione}

\begin{definizione}[\textbf{Embedding Ordinato}]
È una condizione più forte della monotonia. La funzione preserva l'ordine in entrambe le direzioni:
\[ x_1 \sqsubseteq x_2 \iff f(x_1) \sqsubseteq f(x_2) \]
La struttura dell'ordine viene conservata perfettamente nel passaggio da $X$ a $Y$.
\end{definizione}

\begin{definizione}[\textbf{Isomorfismo}]
È un embedding ordinato che è anche \textbf{suriettivo} (copre tutto il codominio $Y$). Significa che i due poset $X$ e $Y$ sono strutturalmente identici.
\end{definizione}

\vspace{0.5cm}

\begin{center}
\begin{tikzpicture}

    \begin{scope}
        \node at (2, 4.5) {\textbf{Funzione Monotona}};
        
        \node at (0,3) (x1) {1};
        \node at (0,2) (x0) {0};
        \node at (0,1) (xm1) {-1};
        \draw (xm1) -- (x0) -- (x1);
        \node at (0, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \node at (4,3) (y1) {1};
        \node at (4,2) (y0) {0};
        \node at (4,1) (ym1) {-1};
        \draw (ym1) -- (y0) -- (y1);
        \node at (4, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \draw[->, color=myred, thick] (x1) -- (y1);
        \draw[->, color=myred, thick] (x0) -- (y1);
        \draw[->, color=myred, thick] (xm1) -- (y0);

        \node at (2, -1.5) {\parbox{6cm}{\centering Se $x$ sale, la freccia non scende mai ($f(x_1) \sqsubseteq f(x_2)$).}};
    \end{scope}

    \begin{scope}[xshift=7.5cm]
        \node at (2.5, 4.5) {\textbf{Embedding Ordinato}};
        
        \node at (0,3) (x1) {1};
        \node at (0,2) (x0) {0};
        \node at (0,1) (xm1) {-1};
        \draw (xm1) -- (x0) -- (x1);
        \node at (0, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \node at (5,3) (y3) {3};
        \node at (5,2) (y2) {2};
        \node at (5,1) (y1) {1};
        \draw (y1) -- (y2) -- (y3);
        \node at (5, 0) {$\langle \mathbb{Z}, \le \rangle$};

        \draw[->, color=blue, thick] (x1) -- (y3); 
        \draw[->, color=blue, thick] (x0) -- (y2);
        \draw[->, color=blue, thick] (xm1) -- (y1);

        \node at (2.5, -1.5) {\parbox{6cm}{\centering Struttura copiata identica ($f(x)=x+2$).\\ Iniettiva e bidirezionale.}};
    \end{scope}

\end{tikzpicture}
\end{center}
\section{Teoria del Punto Fisso e Terminazione}

Questa sezione copre i concetti matematici necessari per garantire che l'analisi statica termini e produca risultati corretti, specialmente in presenza di cicli.

\subsection{Chains (Catene)}

\begin{definizione}[\textbf{Catena}]
Dato un poset $\langle X, \sqsubseteq \rangle$, un sottoinsieme $C \subseteq X$ è una \textbf{catena} se è totalmente ordinato, ovvero tutti gli elementi sono confrontabili tra loro:
\[ \forall x, y \in C \implies (x \sqsubseteq y \lor y \sqsubseteq x) \]
\end{definizione}

\noindent \textbf{Catena Ascendente:} Una sequenza indicizzata $(l_n)_{n \in \mathbb{N}}$ tale che $i \le j \implies l_i \sqsubseteq l_j$.
\[ l_0 \sqsubseteq l_1 \sqsubseteq l_2 \sqsubseteq \dots \]
Nell'analisi statica, le catene ascendenti rappresentano l'accumulo progressivo di informazioni durante le iterazioni.

\subsection{ACC (Ascending Chain Condition)}

Questa proprietà è fondamentale per garantire la \textbf{terminazione} degli algoritmi di analisi.

\begin{definizione}[\textbf{ACC}]
Un poset soddisfa la \textbf{Ascending Chain Condition} se ogni catena ascendente infinita alla fine si \textbf{stabilizza}. Esiste un indice $k$ oltre il quale il valore non cambia più:
\[ \exists k \ge 0 \text{ tale che } \forall j \ge k, l_k = l_j \]
\end{definizione}

\noindent \textit{Intuizione:} Non è possibile "crescere" all'infinito. Se il dominio ha la ACC (es. è finito), l'analizzatore non andrà mai in loop infinito.

\subsection{Mappe Continue}

\begin{definizione}[\textbf{Funzione Continua}]
Siano $X$ e $Y$ due CPO (Complete Partial Orders). Una funzione $f: X \to Y$ è \textbf{continua} se preserva i limiti delle catene (i LUB):
\[ f\left(\bigsqcup C\right) = \bigsqcup_{c \in C} f(c) \]
\end{definizione}

\noindent \textbf{Nota:} La continuità è una condizione più forte della monotonia. È necessaria per applicare il Teorema di Kleene.

\subsection{Fixpoint (Punto Fisso)}

I punti fissi forniscono la semantica dei costrutti ciclici (loop).

\begin{definizione}[\textbf{Punto Fisso}]
Dato un insieme $X$ e una funzione $f: X \to X$, un elemento $x \in X$ è un punto fisso se:
\[ f(x) = x \]
\end{definizione}

\noindent Nell'analisi statica cerchiamo il \textbf{Least Fixpoint (lfp)}, ovvero il punto fisso più piccolo, che rappresenta l'insieme minimo dei comportamenti possibili del programma.

\subsubsection{Teoremi fondamentali}

\begin{itemize}
    \item \textbf{\textcolor{myblue}{Teorema di Knaster-Tarski:}} Se $\langle X, \sqsubseteq \rangle$ è un reticolo completo e $f$ è \textbf{monotona}, allora l'insieme dei punti fissi è un reticolo completo e il lfp esiste. \\
    \textit{Limite:} Non dice come calcolarlo (non costruttivo).
    
    \item \textbf{\textcolor{myblue}{Teorema di Kleene:}} Se $\langle X, \sqsubseteq \rangle$ è un CPO e $f$ è \textbf{continua}, allora il lfp è il limite dell'iterazione partendo dal basso ($\bot$):
    \[ lfp(f) = \bigsqcup_{n \in \mathbb{N}} f^n(\bot) \]
    \textit{Vantaggio:} Fornisce un algoritmo costruttivo (iterativo) usato dagli analizzatori.
\end{itemize}

\newpage

\section{Il Linguaggio IMP}

IMP è un linguaggio imperativo minimale ("toy language") utilizzato per modellare formalmente la semantica senza la complessità dei linguaggi reali. È Turing-completo.

\subsection{Sintassi}

La sintassi è divisa in tre categorie sintattiche:

\begin{enumerate}
    \item \textbf{Espressioni Aritmetiche ($e$):} Calcolano valori interi.
    \[ e ::= x \mid n \mid e_1 \ op_a \ e_2 \]
    \textit{Dove:} $x$ è una variabile, $n \in \mathbb{Z}$, $op_a \in \{+, -, *, \div\}$.

    \item \textbf{Espressioni Booleane ($b$):} Calcolano valori di verità (condizioni).
    \[ b ::= \text{true} \mid \text{false} \mid \neg b \mid b_1 \ op_b \ b_2 \mid e_1 \ op_c \ e_2 \]
    \textit{Dove:} $op_b \in \{\land, \lor\}$, $op_c \in \{==, <, >, \le\}$.

    \item \textbf{Statement (Comandi, $s$):} Modificano lo stato della memoria.
    \[ s ::= x := e \mid \text{skip} \mid s_1 ; s_2 \mid \text{if } b \text{ then } s_1 \text{ else } s_2 \mid \text{while } b \text{ do } s \]
\end{enumerate}

\subsection{Esempio di programma IMP}
Un programma che calcola la somma dei numeri da 0 a $x$:

\begin{verbatim}
y := 0;
while x > 0 do
    y := y + x;
    x := x - 1
\end{verbatim}

\section{Semantica delle Tracce}

\subsection{Definizione di Traccia}

\begin{definizione}[\textbf{Traccia}]
Una traccia $\tau \in X^\infty$ è una sequenza di stati che rappresenta una singola evoluzione del programma:
\begin{itemize}
    \item \textbf{Finite:} L'esecuzione termina in uno stato finale (es. il programma finisce).
    \item \textbf{Infinite:} L'esecuzione non termina (es. un ciclo \texttt{while(true)}).
    \item \textbf{Parziali:} Rappresentano un prefisso dell'esecuzione fino a un certo punto intermedio (es. se interrompiamo l'analisi).
\end{itemize}
\end{definizione}

\subsection{Semantica Concreta come Reticolo}
L'insieme di \textbf{tutte} le possibili esecuzioni (semantica concreta) viene modellato utilizzando un reticolo basato sul powerset delle tracce:
\[ \langle \wp(X^\infty), \subseteq, \cup, \cap \rangle \]
L'obiettivo è calcolare questo insieme per catturare sia le esecuzioni che terminano correttamente, sia quelle che divergono (loop infiniti).

\subsection{Calcolo tramite Least Fixpoint (lfp)}

La semantica del programma $P$ si calcola cercando il \textbf{Least Fixpoint} della sua funzione di transizione $F_P$. Utilizzando il Teorema di Kleene, procediamo in modo iterativo partendo dal basso :

\[ lfp(F_P) = \bigcup_{n \in \mathbb{N}} F_P^n(\bot) \]

\noindent \textbf{La procedura iterativa:}
L'iterazione costruisce la semantica passo dopo passo:
\begin{enumerate}
    \item \textbf{Passo 0 ($F^0(\bot) = \bot$):} Stato vuoto o non inizializzato.
    \item \textbf{Passo 1 ($F^1(\bot)$):} Tracce di lunghezza 1 (stati iniziali).
    \item \textbf{Passo $k$ ($F^k(\bot)$):} Insieme delle esecuzioni parziali di lunghezza fino a $k$.
\end{enumerate}

Il processo termina quando si raggiunge un punto fisso, ovvero quando l'aggiunta di un nuovo passo non scopre nuove tracce ($F^{k+1} = F^k$).

\vspace{1cm}

\noindent \textbf{Rappresentazione Grafica delle Tracce:}

\begin{center}
\begin{tikzpicture}[x=1.5cm, y=1cm]
    \draw[->] (0,0) -- (6,0) node[right] {Tempo discreto ($t$)};
    \draw[->] (0,0) -- (0,3.5) node[above] {Stato $x(t)$};

    \node[circle, fill=mygreen, inner sep=1.5pt, label=left:\textcolor{mygreen}{Inizio}] (s0) at (0,1) {};
    \node[circle, fill=mygreen, inner sep=1.5pt] (s1) at (1,1.5) {};
    \node[circle, fill=mygreen, inner sep=1.5pt] (s2) at (2,1.2) {};
    \node[circle, fill=mygreen, inner sep=1.5pt, label=right:\textcolor{mygreen}{Fine}] (s3) at (3,0.5) {};
    \draw[->, thick, mygreen] (s0) -- (s1) -- (s2) -- (s3);
    \node[mygreen] at (3.5, 1) {\small Traccia Finita};

    \node[circle, fill=myred, inner sep=1.5pt, label=left:\textcolor{myred}{Inizio}] (i0) at (0,2.5) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i1) at (1,2.2) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i2) at (2,2.8) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i3) at (3,2.5) {};
    \node[circle, fill=myred, inner sep=1.5pt] (i4) at (4,2.9) {};
    \node (i_inf) at (5.5, 2.7) {\dots};
    \draw[->, thick, myred] (i0) -- (i1) -- (i2) -- (i3) -- (i4) -- (i_inf);
    \node[myred] at (4, 3.2) {\small Traccia Infinita (Loop)};

    \foreach \x in {0,1,2,3,4,5}
        \draw (\x, 0.1) -- (\x, -0.1) node[below] {\x};

\end{tikzpicture}
\end{center}
\newpage

% --- Nuove Definizioni per il Capitolo ---
\definecolor{bg_gray}{RGB}{245, 245, 245}

\newtheorem{esempio}{Esempio}[section]

\newenvironment{spiegazione}
{\vspace{0.2cm}\noindent\textbf{\textcolor{mygreen}{In parole semplici:}}\itshape}
{\vspace{0.2cm}}

\newcommand{\examquestion}[1]{
    \begin{center}
    \fcolorbox{myred}{bg_gray}{
        \parbox{0.9\textwidth}{
            \textbf{\textcolor{myred}{Possibile domanda d'esame:}}\\
            #1
        }
    }
    \end{center}
}

\section{Panoramica di un Analizzatore Statico}

Un analizzatore statico è un software complesso composto da diversi moduli che lavorano insieme per trasformare il codice sorgente in risultati di analisi (come la segnalazione di bug o garanzie di correttezza).

\subsection{Componenti Principali}

Il flusso di lavoro di un analizzatore statico segue questi passaggi logici:

\begin{enumerate}
    \item \textbf{Programma (Input):} Il codice sorgente che si vuole analizzare.
    \item \textbf{IR (Rappresentazione Interna):} Il codice viene tradotto in una forma intermedia (es. Control Flow Graph) più facile da manipolare per l'analisi.
    \item \textbf{Engine di Analisi:} Il "cuore" del sistema. Gestisce l'algoritmo di punto fisso, la risoluzione delle chiamate a funzione e la gestione della memoria.
    \item \textbf{Dominio Astratto:} L'astrazione dei dati su cui lavora l'algoritmo (es. Intervalli, Segni, Costanti).
    \item \textbf{Risultato:} L'output dell'analisi (warnings, report).
\end{enumerate}

\begin{spiegazione}
L'idea fondamentale è la \textbf{modularità}. Se vuoi analizzare un nuovo linguaggio (es. passare da Java a C++) o cambiare il tipo di analisi (es. da intervalli a segni), non devi riscrivere tutto. I componenti devono essere indipendenti: l'algoritmo di punto fisso non deve sapere che linguaggio stai analizzando, deve solo lavorare sul grafo astratto (IR).
\end{spiegazione}

\begin{center}
    \includegraphics[width=0.8\textwidth]{static_analyzer.png}
\end{center}

\examquestion{Quali sono i componenti principali di un analizzatore statico e perché è importante che siano modulari?}

\newpage

\section{LiSA (Library for Static Analysis)}

\textbf{LiSA} è una libreria open-source scritta in Java per costruire analizzatori statici basati sull'Interpretazione Astratta.

\subsection{Architettura e Flusso di Lavoro}

In LiSA, il processo di analisi avviene attraverso i seguenti step:

\begin{enumerate}
    \item \textbf{Front-end:} Un componente specifico per ogni linguaggio (Java, C, IMP, ecc.) traduce il codice sorgente nei CFG (Control Flow Graphs) di LiSA.
    \item \textbf{LiSA Core:} Il motore di analisi generico che prende i CFG e li analizza. Include:
    \begin{itemize}
        \item \textbf{CFG Fixpoint:} L'algoritmo che calcola il punto fisso sul grafo.
        \item \textbf{Statement Semantics:} La logica per interpretare le istruzioni.
        \item \textbf{Domain:} L'implementazione dei domini astratti (es. Intervalli).
        \item \textbf{Memory Handling:} La gestione della memoria (heap, stack).
    \end{itemize}
    \item \textbf{Checks:} Controlli finali sui risultati per generare warnings.
\end{enumerate}

\subsubsection*{Approfondimento: La Metafora della Catena di Montaggio}

Immagina LiSA come una \textbf{catena di montaggio universale} per analizzare programmi. Il suo obiettivo è prendere codice scritto in lingue diverse (Java, C, Python) e capire se è corretto, usando sempre lo stesso "macchinario" centrale.

Ecco la spiegazione dettagliata dei tre step:

\paragraph{1. Front-end: Il Traduttore Universale}
Il problema principale dell'analisi statica è che ogni linguaggio di programmazione ha una sintassi diversa. Scrivere un analizzatore per Java e uno per C richiederebbe di riscrivere tutto da zero due volte.

\begin{itemize}
    \item \textbf{Cosa fa:} Il Front-end agisce come un interprete. Prende il codice sorgente (il file \texttt{.java} o \texttt{.c}) e lo traduce in un linguaggio che LiSA capisce: il \textbf{CFG (Control Flow Graph)}.
    \item \textbf{Perché è utile:} Una volta che il codice è diventato un CFG di LiSA, il resto dell'analizzatore non deve più preoccuparsi se l'originale era Java o C. Vede solo nodi (istruzioni) e archi (flusso).
\end{itemize}

\paragraph{2. LiSA Core: Il Motore di Analisi}
Questo è il cervello del sistema. Una volta ricevuto il CFG "tradotto", il Core deve eseguirlo in modo astratto per trovare le proprietà del programma. È composto da quattro pezzi fondamentali che lavorano insieme:

\begin{itemize}
    \item \textbf{A. CFG Fixpoint (L'Algoritmo):} Immagina questo componente come il \textbf{direttore dei lavori}.
    \begin{itemize}
        \item Il suo compito è percorrere il grafo (CFG) e propagare le informazioni da un nodo all'altro.
        \item Usa un algoritmo iterativo (basato sulla \textit{worklist}). Continua a far girare le informazioni nel grafo finché queste non si stabilizzano (raggiungono il \textit{punto fisso}), cioè finché non cambiano più.
    \end{itemize}

    \item \textbf{B. Statement Semantics (Il Dizionario dei Significati):} Il grafo contiene istruzioni generiche. Questo componente spiega al motore \textit{cosa} significano quelle istruzioni.
    \begin{itemize}
        \item \textit{Esempio:} Se nel grafo c'è un nodo che dice \texttt{x = a + b}, la \textit{Statement Semantics} dice: "Attenzione, questo simbolo \texttt{+} significa 'somma aritmetica', non concatenazione". Traduce la sintassi in un'operazione logica che il dominio può capire.
    \end{itemize}

    \item \textbf{C. Domain (La Lente di Ingrandimento):} Questo è il componente che decide \textbf{cosa} stiamo osservando dei dati.
    \begin{itemize}
        \item Il motore chiede: "Ho la variabile \texttt{x}, come la rappresento?".
        \item Se il Dominio è \textbf{Intervalli}, risponde: "Rappresentala come \texttt{[min, max]}".
        \item Se il Dominio è \textbf{Segni}, risponde: "Dimmi solo se è \texttt{+} o \texttt{-}".
        \item È qui che avvengono i calcoli veri (es. \texttt{[1, 5] + [2, 3] = [3, 8]}).
    \end{itemize}

    \item \textbf{D. Memory Handling (La Mappa):} Questo componente gestisce \textbf{dove} sono salvati i dati.
    \begin{itemize}
        \item In un programma reale, abbiamo variabili locali (nello stack) e oggetti dinamici (nello heap).
        \item LiSA deve sapere che la variabile \texttt{x} in una funzione è diversa dalla variabile \texttt{x} in un'altra, o che \texttt{p.val} si riferisce a una specifica cella di memoria. Il \textit{Memory Handling} trasforma nomi complessi in indirizzi astratti univoci.
    \end{itemize}
\end{itemize}

\paragraph{3. Checks: L'Ispettore Finale}
Una volta che il Core ha finito di girare, abbiamo un grafo "decorato": ogni punto del programma ha associato uno stato astratto (es. "qui \texttt{x} vale \texttt{[0, 10]}").

\begin{itemize}
    \item \textbf{Cosa fa:} I \textit{Checks} scorrono questi risultati e verificano se violano delle regole.
    \item \textbf{Esempio:} Se c'è un'istruzione \texttt{y = 10 / x} e l'analisi ha calcolato che in quel punto \texttt{x} vale \texttt{[0, 5]}, il Check vede che lo \texttt{0} è incluso nell'intervallo e lancia un allarme (Warning): "Possibile divisione per zero!".
\end{itemize}

\begin{esempio}[\textbf{Riassunto pratico}]
Immagina di analizzare \texttt{x = 10 / y}:
\begin{enumerate}
    \item \textbf{Front-end:} Legge il file e crea un grafo con un nodo per la divisione.
    \item \textbf{LiSA Core:}
    \begin{itemize}
        \item \textbf{Fixpoint:} Arriva al nodo della divisione portandosi dietro le informazioni precedenti.
        \item \textbf{Memory:} Capisce quale \texttt{x} e quale \texttt{y} stiamo usando.
        \item \textbf{Semantics:} Capisce che \texttt{/} è una divisione matematica.
        \item \textbf{Domain:} Calcola il risultato astratto (es. \texttt{Intervallo(10) / Intervallo(y)}).
    \end{itemize}
    \item \textbf{Checks:} Controlla se il divisore \texttt{y} poteva essere \texttt{0}. Se sì, ti avvisa.
\end{enumerate}
\end{esempio}

\subsection{Struttura del CFG in LiSA}

Un Control Flow Graph in LiSA è costituito da:
\begin{itemize}
    \item \textbf{Nodi:} Rappresentano gli statement (istruzioni) del programma.
    \item \textbf{Archi:} Collegano i nodi e rappresentano il flusso. Possono essere:
    \begin{itemize}
        \item \textbf{Sequential Edge:} Flusso normale sequenziale.
        \item \textbf{True Edge:} Preso quando una condizione è vera (ramo \texttt{then}).
        \item \textbf{False Edge:} Preso quando una condizione è falsa (ramo \texttt{else}).
    \end{itemize}
\end{itemize}

\begin{spiegazione}
Usare i CFG permette a LiSA di "dimenticare" la sintassi specifica del linguaggio originale (es. come si scrive un ciclo \texttt{while} in C vs Python) e lavorare su una struttura a grafo unificata.
\end{spiegazione}

\examquestion{Descrivere i tipi di archi presenti in un CFG di LiSA e la loro funzione.}

\newpage

\section{Sintassi vs Semantica}

Un concetto chiave in LiSA è la distinzione tra lo statement sintattico e il suo significato semantico.

\begin{definizione}[\textbf{Rewriting Semantico}]
Diverse operazioni sintattiche possono avere lo stesso significato semantico. LiSA utilizza un linguaggio interno di \textbf{Espressioni Simboliche} per uniformare queste differenze.
\end{definizione}

\textbf{Esempio:}
In Java, l'operatore \texttt{+} può significare:
\begin{itemize}
    \item Somma aritmetica: \texttt{1 + 2}
    \item Concatenazione di stringhe: \texttt{"a" + "b"}
\end{itemize}
Il dominio astratto non deve preoccuparsi della sintassi. LiSA traduce lo statement in un'espressione simbolica "atomica":
\begin{itemize}
    \item Se sono numeri $\rightarrow$ \texttt{ArithmSum}
    \item Se sono stringhe $\rightarrow$ \texttt{StringConcat}
\end{itemize}
In questo modo, il dominio astratto implementa solo la logica per \texttt{ArithmSum} o \texttt{StringConcat}, indipendentemente da come erano scritte nel codice originale.

\examquestion{Perché LiSA distingue tra lo statement sintattico e la sua semantica tramite espressioni simboliche? Fornire un esempio.}

\section{Implementazione dell'Analisi Dataflow}

LiSA fornisce un'architettura specifica per implementare analisi dataflow (come quelle viste nel Cap. 4).

\subsection{Algoritmo Generico (Worklist)}

Le analisi dataflow in LiSA sfruttano un algoritmo di punto fisso generico basato su \textbf{worklist}. L'implementazione è divisa in due classi principali per separare la logica:

\begin{itemize}
    \item \textbf{DataflowDomain:} Gestisce la logica generale del reticolo e l'operazione di Join.
    \begin{itemize}
        \item \texttt{PossibleForwardDataflowDomain}: Implementa analisi \textbf{May} (usa l'Unione $\cup$).
        \item \texttt{DefiniteForwardDataflowDomain}: Implementa analisi \textbf{Must} (usa l'Intersezione $\cap$).
    \end{itemize}
    \item \textbf{DataflowElement:} Rappresenta il singolo elemento tracciato (es. una variabile viva, un'espressione disponibile). Definisce le operazioni specifiche \textbf{Gen} e \textbf{Kill}.
\end{itemize}

\begin{spiegazione}
Questa struttura permette di implementare una nuova analisi (es. Reaching Definitions) scrivendo solo la logica di Gen/Kill nel \texttt{DataflowElement}, mentre il \texttt{DataflowDomain} gestisce automaticamente il calcolo del punto fisso e la propagazione nel grafo.
\end{spiegazione}

\textbf{Nota:} Attualmente LiSA supporta nativamente solo analisi \textbf{Forward}.

\end{document}